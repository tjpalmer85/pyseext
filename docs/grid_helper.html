<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyseext.grid_helper API documentation</title>
<meta name="description" content="Module that contains our GridHelper class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyseext.grid_helper</code></h1>
</header>
<section id="section-intro">
<p>Module that contains our GridHelper class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that contains our GridHelper class.
&#34;&#34;&#34;
import logging
import random
from typing import Union

from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.remote.webelement import WebElement

from pyseext.has_referenced_javascript import HasReferencedJavaScript
from pyseext.component_query import ComponentQuery
from pyseext.input_helper import InputHelper
from pyseext.menu_helper import MenuHelper
from pyseext.store_helper import StoreHelper

class GridHelper(HasReferencedJavaScript):
    &#34;&#34;&#34;A class to help with interacting with Ext grid panels&#34;&#34;&#34;

    # Public class properties
    GRID_CQ: str = &#34;gridpanel&#34;
    &#34;&#34;&#34;The component query to use to find a grid panel&#34;&#34;&#34;

    # Private class variables
    _GET_COLUMN_HEADER_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.getColumnHeader(&#39;{grid_cq}&#39;, &#39;{column_text_or_data_index}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.getColumnHeader
    Requires the inserts: {grid_cq}, {column_text_or_data_index}&#34;&#34;&#34;

    _GET_COLUMN_HEADER_TRIGGER_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.getColumnHeaderTrigger(&#39;{grid_cq}&#39;, &#39;{column_text_or_data_index}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.getColumnHeaderTrigger
    Requires the inserts: {grid_cq}, {column_text_or_data_index}&#34;&#34;&#34;

    _CLEAR_SELECTION_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.clearSelection(&#39;{grid_cq}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.clearSelection
    Requires the inserts: {grid_cq}&#34;&#34;&#34;

    _GET_ROW_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.getRow(&#39;{grid_cq}&#39;, {row_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.getRow
    Requires the inserts: {grid_cq}, {row_data}&#34;&#34;&#34;

    def __init__(self, driver: WebDriver):
        &#34;&#34;&#34;Initialises an instance of this class

        Args:
            driver (WebDriver): The webdriver to use
        &#34;&#34;&#34;

        # Instance variables
        self._logger = logging.getLogger(__name__)
        &#34;&#34;&#34;The Logger instance for this class instance&#34;&#34;&#34;

        self._driver = driver
        &#34;&#34;&#34;The WebDriver instance for this class instance&#34;&#34;&#34;

        self._cq = ComponentQuery(driver)
        &#34;&#34;&#34;The `ComponentQuery` instance for this class instance&#34;&#34;&#34;

        self._input_helper = InputHelper(driver)
        &#34;&#34;&#34;The `InputHelper` instance for this class instance&#34;&#34;&#34;

        self._menu_helper = MenuHelper(driver)
        &#34;&#34;&#34;The `MenuHelper` instance for this class instance&#34;&#34;&#34;

        self._store_helper = StoreHelper(driver)
        &#34;&#34;&#34;The `StoreHelper` instance for this class instance&#34;&#34;&#34;

        self._action_chains = ActionChains(driver)
        &#34;&#34;&#34;The ActionChains instance for this class instance&#34;&#34;&#34;

        # Initialise our base class
        super().__init__(driver, self._logger)

    def get_column_header(self, grid_cq: str, column_text_or_data_index: str) -&gt; WebElement:
        &#34;&#34;&#34;Gets the element for the specified column header

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            WebElement: The DOM element for the column header
        &#34;&#34;&#34;

        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        script = self._GET_COLUMN_HEADER_TEMPLATE.format(grid_cq=grid_cq, column_text_or_data_index=column_text_or_data_index)
        self.ensure_javascript_loaded()
        column_header = self._driver.execute_script(script)

        if column_header:
            return column_header

        raise GridHelper.ColumnNotFoundException(grid_cq, column_text_or_data_index)

    def is_column_visible(self, grid_cq: str, column_text_or_data_index: str) -&gt; bool:
        &#34;&#34;&#34;Determines whether the specified column is visible,
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            True if the column is visible, False otherwise.
        &#34;&#34;&#34;
        return self.get_column_header(grid_cq, column_text_or_data_index).is_displayed()

    def is_column_hidden(self, grid_cq: str, column_text_or_data_index: str) -&gt; bool:
        &#34;&#34;&#34;Determines whether the specified column is hidden.
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            True if the column is hidden, False otherwise.
        &#34;&#34;&#34;
        return not self.get_column_header(grid_cq, column_text_or_data_index).is_displayed()

    def check_columns_are_visible(self, grid_cq: str, column_text_or_data_indexes: list[str]) -&gt; list[WebElement]:
        &#34;&#34;&#34;Checks that the specified columns are all visible on the specified grid.
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_indexes (list[str]): An array containing the header text or dataIndex of the grid columns to check

        Returns:
            An array of columns that are not visible, if any.
        &#34;&#34;&#34;
        columns_not_visible = []

        for column_text_or_data_index in column_text_or_data_indexes:
            is_visible = self.is_column_visible(grid_cq, column_text_or_data_index)
            if not is_visible:
                columns_not_visible.append(column_text_or_data_index)

        return columns_not_visible

    def check_columns_are_hidden(self, grid_cq: str, column_texts_or_data_indexes: list[str]) -&gt; list[WebElement]:
        &#34;&#34;&#34;Checks that the specified columns are all hidden on the specified grid.
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_texts_or_data_indexes (list[str]): An array containing the header text or dataIndex of the grid columns to check

        Returns:
            An array of columns that are not hidden, if any.
        &#34;&#34;&#34;
        column_not_hidden = []

        for column_text_or_data_index in column_texts_or_data_indexes:
            is_hidden = self.is_column_hidden(grid_cq, column_text_or_data_index)
            if not is_hidden:
                column_not_hidden.append(column_text_or_data_index)

        return column_not_hidden

    def click_column_header(self, grid_cq: str, column_text_or_data_index: str):
        &#34;&#34;&#34;Clicks on the specified column header.
        The column must be visible.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column
        &#34;&#34;&#34;
        column_header = self.get_column_header(grid_cq, column_text_or_data_index)

        self._logger.info(&#34;Clicking column header &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, column_text_or_data_index, grid_cq)

        self._action_chains.move_to_element(column_header)
        self._action_chains.click()
        self._action_chains.perform()

    def get_column_header_trigger(self, grid_cq: str, column_text_or_data_index: str) -&gt; WebElement:
        &#34;&#34;&#34;Gets the element for the specified column header&#39;s trigger

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            WebElement: The DOM element for the column header trigger.
        &#34;&#34;&#34;

        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        script = self._GET_COLUMN_HEADER_TRIGGER_TEMPLATE.format(grid_cq=grid_cq, column_text_or_data_index=column_text_or_data_index)
        self.ensure_javascript_loaded()
        column_header_trigger = self._driver.execute_script(script)

        if column_header_trigger:
            return column_header_trigger

        raise GridHelper.ColumnNotFoundException(grid_cq, column_text_or_data_index)

    def click_column_header_trigger(self, grid_cq: str, column_text_or_data_index: str):
        &#34;&#34;&#34;Clicks on the specified column header&#39;s trigger

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column
        &#34;&#34;&#34;
        # We need to move to the header before the trigger becomes interactable
        column_header = self.get_column_header(grid_cq, column_text_or_data_index)
        self._action_chains.move_to_element(column_header).perform()

        column_header_trigger = self.get_column_header_trigger(grid_cq, column_text_or_data_index)

        self._logger.info(&#34;Clicking column header trigger &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, column_text_or_data_index, grid_cq)

        self._action_chains.move_to_element(column_header_trigger)
        self._action_chains.click()
        self._action_chains.perform()

    def filter_string_column(self, grid_cq: str, column_text_or_data_index: str, filter_value: str, wait_for_store_loaded: bool = True, clear_first: bool = False):
        &#34;&#34;&#34;Filters a string column on a grid for the specified value.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            filter_value (str): The value to filter the column by.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
            clear_first (bool, optional): Indicates whether to clear the filter element first. Defaults to False.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

        filter_textbox = self._cq.wait_for_single_query_visible(&#39;textfield[emptyText=&#34;Enter Filter Text...&#34;]&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        self._input_helper.type_into_element(filter_textbox, filter_value, clear_first = clear_first)

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def filter_list_column(self, grid_cq: str, column_text_or_data_index: str, filter_values_to_toggle: list[str], wait_for_store_loaded: bool = True):
        &#34;&#34;&#34;Toggles the values on a list filtered column on a grid.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            filter_values_to_toggle (list[str]): The filter values to toggle.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        for filter_value_to_toggle in filter_values_to_toggle:
            self._menu_helper.click_menu_item_by_text(filter_value_to_toggle)

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def filter_number_column(self,
                             grid_cq: str,
                             column_text_or_data_index: str,
                             equal_to: Union[None, float] = None,
                             less_than: Union[None, float] = None,
                             greater_than: Union[None, float] = None,
                             wait_for_store_loaded: bool = True):
        &#34;&#34;&#34;Filters a number column on a grid for the specified values.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            filter_values_to_toggle (list[str]): The filter values to toggle.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        filter_textboxes = self._cq.wait_for_query(&#39;textfield[emptyText=&#34;Enter Number...&#34;]&#39;)

        # clear_first does not work with these :/
        # Double-clicking then either typing or deleting should do it.
        self._action_chains.move_to_element(filter_textboxes[0])
        self._action_chains.double_click()
        self._action_chains.perform()

        if less_than is not None:
            self._input_helper.type_into_element(filter_textboxes[0], less_than, clear_first = False)
        else:
            self._input_helper.type_delete()

        self._action_chains.move_to_element(filter_textboxes[1])
        self._action_chains.double_click()
        self._action_chains.perform()

        if greater_than is not None:
            self._input_helper.type_into_element(filter_textboxes[1], greater_than, clear_first = False)
        else:
            self._input_helper.type_delete()

        self._action_chains.move_to_element(filter_textboxes[2])
        self._action_chains.double_click()
        self._action_chains.perform()

        if equal_to is not None:
            self._input_helper.type_into_element(filter_textboxes[2], equal_to, clear_first = False)
        else:
            self._input_helper.type_delete()

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def toggle_column_filter(self, grid_cq: str, column_text_or_data_index: str, wait_for_store_loaded: bool = True):
        &#34;&#34;&#34;Toggles the filter on a column by clicking on the filters element.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        filter_menu_item = self._menu_helper.try_get_menu_item_by_text(&#39;Filters&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        self._action_chains.move_to_element(filter_menu_item)
        self._action_chains.click()
        self._action_chains.perform()

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def clear_selection(self, grid_cq: str):
        &#34;&#34;&#34; Clears the current selection.

        Useful if want to quickly refresh a grid without having to process all the events.
        This will only work if the grid supports deselection.

        Args:
            grid_cq (str): The component query for the grid
        &#34;&#34;&#34;
        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        self._logger.info(&#34;Clearing selection on grid with CQ &#39;%s&#39;&#34;, grid_cq)

        script = self._CLEAR_SELECTION_TEMPLATE.format(grid_cq=grid_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    def get_row(self, grid_cq: str, row_data: Union[int, dict], should_throw_exception: bool = True) -&gt; WebElement:
        &#34;&#34;&#34; Gets the element for the row with the specified data or index in the grid.

        The grid must be visible.

        Args:
            grid_cq (str): The component query for the grid
            row_data (Union[int, dict]): The row data or index for the record to be found.
            should_throw_exception (bool): Indicates whether this method should throw an exception
                                           if the row is not found. Defaults to True.

        Returns:
            WebElement: The DOM element for the row or None if not found (and not thrown)
        &#34;&#34;&#34;
        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        script = self._GET_ROW_TEMPLATE.format(grid_cq=grid_cq, row_data=row_data)
        self.ensure_javascript_loaded()
        row = self._driver.execute_script(script)

        if row or not should_throw_exception:
            return row

        raise GridHelper.RowNotFoundException(grid_cq, row_data)

    def click_row(self, grid_cq: str, row_data: Union[int, dict]):
        &#34;&#34;&#34; Clicks the row with the specified data or index in the grid.

        The grid must be visible.

        Args:
            grid_cq (str): The component query for the grid
            row_data (Union[int, dict]): The row data or index for the record to be found and clicked.
        &#34;&#34;&#34;
        # Check grid can be found and is visible
        row = self.get_row(grid_cq, row_data)

        self._logger.info(&#34;Clicking clicking row &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, row_data, grid_cq)

        self._action_chains.move_to_element(row)
        self._action_chains.click()
        self._action_chains.perform()

    def wait_for_row(self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60) -&gt; WebElement:
        &#34;&#34;&#34;Waits for the specified row to appear in the grid, reloading the store until
        it is found, or until the timeout is hit.

        Args:
            grid_cq (str): The component query for the grid.
            row_data (Union[int, dict]): The row data or index of the record we are waiting for.
            timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.

        Returns:
            WebElement: The DOM element for the row
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout).until(GridHelper.RowFoundExpectation(grid_cq, row_data))
        return self.get_row(grid_cq, row_data)

    def wait_to_click_row(self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60):
        &#34;&#34;&#34;Waits for the specified row to appear in the grid, reloading the store until
        it is found, or until the timeout is hit.
        Once we have found the row it is clicked.

        Args:
            grid_cq (str): The component query for the grid.
            row_data (Union[int, dict]): The row data or index of the record we are waiting for.
            timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout).until(GridHelper.RowFoundExpectation(grid_cq, row_data))
        self.click_row(grid_cq, row_data)

    def toggle_columns(self, grid_cq: str, column_text_or_data_index: str, columns_to_toggle: list[str]):
        &#34;&#34;&#34;Toggles a list of columns on the specified grid.
        Any that are visible will be hidden, and any that a currently hidden will be shown.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column to use for the interaction.
            columns_to_toggle (list[str]): The list of columns to toggle.
        &#34;&#34;&#34;

        # Use first visible column for our interaction
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)

        # Get the &#39;Columns&#39; menu itema and move to it, so that submenu shows.
        filter_menu_item = self._menu_helper.try_get_menu_item_by_text(&#39;Columns&#39;)
        self._action_chains.move_to_element(filter_menu_item)
        self._action_chains.perform()

        for column in columns_to_toggle:
            # FIXME: If column is off the bottom of the list this&#39;ll blow up...
            column_to_click = self._cq.wait_for_single_query_visible(f&#39;menucheckitem[text=&#34;{column}&#34;]&#39;)

            self._action_chains.move_to_element(column_to_click)
            self._action_chains.pause(random.uniform(self._input_helper.INPUT_SLEEP_MINIMUM, self._input_helper.INPUT_SLEEP_MAXIMUM))
            self._action_chains.click()
            self._action_chains.pause(random.uniform(self._input_helper.INPUT_SLEEP_MINIMUM, self._input_helper.INPUT_SLEEP_MAXIMUM))
            self._action_chains.perform()

        # Close columns submenu, and grid menu.
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    class ColumnNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we failed to find the specified column&#34;&#34;&#34;

        def __init__(self,
                     grid_cq: str,
                     column_text_or_data_index: str,
                     message: str = &#34;Failed to find column with text (or dataIndex) &#39;{column_text_or_data_index}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                grid_cq (str): The CQ used to find the grid
                column_text_or_data_index (str): The header text or dataIndex of the grid column
                message (str, optional): The exception message. Defaults to &#34;Failed to find column with text (or dataIndex) &#39;{column_text_or_data_index}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._grid_cq = grid_cq
            self._column_text_or_data_index = column_text_or_data_index

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(column_text_or_data_index=self._column_text_or_data_index, grid_cq=self._grid_cq)

    class RowNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we failed to find the specified row&#34;&#34;&#34;

        def __init__(self,
                     grid_cq: str,
                     row_data: Union[int, dict],
                     message: str = &#34;Failed to find row with data (or index) &#39;{row_data}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                grid_cq (str): The CQ used to find the grid
                row_data (Union[int, dict]): The row data or index for the record
                message (str, optional): The exception message. Defaults to &#34;Failed to find row with data (or index) &#39;{row_data}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._grid_cq = grid_cq
            self._row_data = row_data

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(row_data=self._row_data, grid_cq=self._grid_cq)

    class RowFoundExpectation:
        &#34;&#34;&#34; An expectation for checking that a row has been found&#34;&#34;&#34;

        def __init__(self, grid_cq: str, row_data: Union[int, dict]):
            &#34;&#34;&#34;Initialises an instance of this class.

            Args:
                grid_cq (str): The component query for the grid.
                row_data (Union[int, dict]): The row data or index of the record we are waiting for.
            &#34;&#34;&#34;
            self._grid_cq = grid_cq
            self._row_data = row_data

        def __call__(self, driver):
            &#34;&#34;&#34;Method that determines whether a row was found.

            If the row is not found the grid is refreshed and the load waited for.
            &#34;&#34;&#34;
            grid_helper = GridHelper(driver)

            row = grid_helper.get_row(self._grid_cq, self._row_data, False)
            if row:
                return True

            # Trigger a reload, and wait for it to complete
            store_helper = StoreHelper(driver)
            store_helper.reset_store_load_count(self._grid_cq)
            store_helper.trigger_reload(self._grid_cq)
            store_helper.wait_for_store_loaded(self._grid_cq)
            return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyseext.grid_helper.GridHelper"><code class="flex name class">
<span>class <span class="ident">GridHelper</span></span>
<span>(</span><span>driver: selenium.webdriver.remote.webdriver.WebDriver)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to help with interacting with Ext grid panels</p>
<p>Initialises an instance of this class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>driver</code></strong> :&ensp;<code>WebDriver</code></dt>
<dd>The webdriver to use</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GridHelper(HasReferencedJavaScript):
    &#34;&#34;&#34;A class to help with interacting with Ext grid panels&#34;&#34;&#34;

    # Public class properties
    GRID_CQ: str = &#34;gridpanel&#34;
    &#34;&#34;&#34;The component query to use to find a grid panel&#34;&#34;&#34;

    # Private class variables
    _GET_COLUMN_HEADER_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.getColumnHeader(&#39;{grid_cq}&#39;, &#39;{column_text_or_data_index}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.getColumnHeader
    Requires the inserts: {grid_cq}, {column_text_or_data_index}&#34;&#34;&#34;

    _GET_COLUMN_HEADER_TRIGGER_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.getColumnHeaderTrigger(&#39;{grid_cq}&#39;, &#39;{column_text_or_data_index}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.getColumnHeaderTrigger
    Requires the inserts: {grid_cq}, {column_text_or_data_index}&#34;&#34;&#34;

    _CLEAR_SELECTION_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.clearSelection(&#39;{grid_cq}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.clearSelection
    Requires the inserts: {grid_cq}&#34;&#34;&#34;

    _GET_ROW_TEMPLATE: str = &#34;return globalThis.PySeExt.GridHelper.getRow(&#39;{grid_cq}&#39;, {row_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.GridHelper.getRow
    Requires the inserts: {grid_cq}, {row_data}&#34;&#34;&#34;

    def __init__(self, driver: WebDriver):
        &#34;&#34;&#34;Initialises an instance of this class

        Args:
            driver (WebDriver): The webdriver to use
        &#34;&#34;&#34;

        # Instance variables
        self._logger = logging.getLogger(__name__)
        &#34;&#34;&#34;The Logger instance for this class instance&#34;&#34;&#34;

        self._driver = driver
        &#34;&#34;&#34;The WebDriver instance for this class instance&#34;&#34;&#34;

        self._cq = ComponentQuery(driver)
        &#34;&#34;&#34;The `ComponentQuery` instance for this class instance&#34;&#34;&#34;

        self._input_helper = InputHelper(driver)
        &#34;&#34;&#34;The `InputHelper` instance for this class instance&#34;&#34;&#34;

        self._menu_helper = MenuHelper(driver)
        &#34;&#34;&#34;The `MenuHelper` instance for this class instance&#34;&#34;&#34;

        self._store_helper = StoreHelper(driver)
        &#34;&#34;&#34;The `StoreHelper` instance for this class instance&#34;&#34;&#34;

        self._action_chains = ActionChains(driver)
        &#34;&#34;&#34;The ActionChains instance for this class instance&#34;&#34;&#34;

        # Initialise our base class
        super().__init__(driver, self._logger)

    def get_column_header(self, grid_cq: str, column_text_or_data_index: str) -&gt; WebElement:
        &#34;&#34;&#34;Gets the element for the specified column header

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            WebElement: The DOM element for the column header
        &#34;&#34;&#34;

        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        script = self._GET_COLUMN_HEADER_TEMPLATE.format(grid_cq=grid_cq, column_text_or_data_index=column_text_or_data_index)
        self.ensure_javascript_loaded()
        column_header = self._driver.execute_script(script)

        if column_header:
            return column_header

        raise GridHelper.ColumnNotFoundException(grid_cq, column_text_or_data_index)

    def is_column_visible(self, grid_cq: str, column_text_or_data_index: str) -&gt; bool:
        &#34;&#34;&#34;Determines whether the specified column is visible,
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            True if the column is visible, False otherwise.
        &#34;&#34;&#34;
        return self.get_column_header(grid_cq, column_text_or_data_index).is_displayed()

    def is_column_hidden(self, grid_cq: str, column_text_or_data_index: str) -&gt; bool:
        &#34;&#34;&#34;Determines whether the specified column is hidden.
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            True if the column is hidden, False otherwise.
        &#34;&#34;&#34;
        return not self.get_column_header(grid_cq, column_text_or_data_index).is_displayed()

    def check_columns_are_visible(self, grid_cq: str, column_text_or_data_indexes: list[str]) -&gt; list[WebElement]:
        &#34;&#34;&#34;Checks that the specified columns are all visible on the specified grid.
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_indexes (list[str]): An array containing the header text or dataIndex of the grid columns to check

        Returns:
            An array of columns that are not visible, if any.
        &#34;&#34;&#34;
        columns_not_visible = []

        for column_text_or_data_index in column_text_or_data_indexes:
            is_visible = self.is_column_visible(grid_cq, column_text_or_data_index)
            if not is_visible:
                columns_not_visible.append(column_text_or_data_index)

        return columns_not_visible

    def check_columns_are_hidden(self, grid_cq: str, column_texts_or_data_indexes: list[str]) -&gt; list[WebElement]:
        &#34;&#34;&#34;Checks that the specified columns are all hidden on the specified grid.
        Throws a ColumnNotFoundException if the column does not exist.

        Args:
            grid_cq (str): The component query for the owning grid
            column_texts_or_data_indexes (list[str]): An array containing the header text or dataIndex of the grid columns to check

        Returns:
            An array of columns that are not hidden, if any.
        &#34;&#34;&#34;
        column_not_hidden = []

        for column_text_or_data_index in column_texts_or_data_indexes:
            is_hidden = self.is_column_hidden(grid_cq, column_text_or_data_index)
            if not is_hidden:
                column_not_hidden.append(column_text_or_data_index)

        return column_not_hidden

    def click_column_header(self, grid_cq: str, column_text_or_data_index: str):
        &#34;&#34;&#34;Clicks on the specified column header.
        The column must be visible.

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column
        &#34;&#34;&#34;
        column_header = self.get_column_header(grid_cq, column_text_or_data_index)

        self._logger.info(&#34;Clicking column header &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, column_text_or_data_index, grid_cq)

        self._action_chains.move_to_element(column_header)
        self._action_chains.click()
        self._action_chains.perform()

    def get_column_header_trigger(self, grid_cq: str, column_text_or_data_index: str) -&gt; WebElement:
        &#34;&#34;&#34;Gets the element for the specified column header&#39;s trigger

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column

        Returns:
            WebElement: The DOM element for the column header trigger.
        &#34;&#34;&#34;

        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        script = self._GET_COLUMN_HEADER_TRIGGER_TEMPLATE.format(grid_cq=grid_cq, column_text_or_data_index=column_text_or_data_index)
        self.ensure_javascript_loaded()
        column_header_trigger = self._driver.execute_script(script)

        if column_header_trigger:
            return column_header_trigger

        raise GridHelper.ColumnNotFoundException(grid_cq, column_text_or_data_index)

    def click_column_header_trigger(self, grid_cq: str, column_text_or_data_index: str):
        &#34;&#34;&#34;Clicks on the specified column header&#39;s trigger

        Args:
            grid_cq (str): The component query for the owning grid
            column_text_or_data_index (str): The header text or dataIndex of the grid column
        &#34;&#34;&#34;
        # We need to move to the header before the trigger becomes interactable
        column_header = self.get_column_header(grid_cq, column_text_or_data_index)
        self._action_chains.move_to_element(column_header).perform()

        column_header_trigger = self.get_column_header_trigger(grid_cq, column_text_or_data_index)

        self._logger.info(&#34;Clicking column header trigger &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, column_text_or_data_index, grid_cq)

        self._action_chains.move_to_element(column_header_trigger)
        self._action_chains.click()
        self._action_chains.perform()

    def filter_string_column(self, grid_cq: str, column_text_or_data_index: str, filter_value: str, wait_for_store_loaded: bool = True, clear_first: bool = False):
        &#34;&#34;&#34;Filters a string column on a grid for the specified value.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            filter_value (str): The value to filter the column by.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
            clear_first (bool, optional): Indicates whether to clear the filter element first. Defaults to False.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

        filter_textbox = self._cq.wait_for_single_query_visible(&#39;textfield[emptyText=&#34;Enter Filter Text...&#34;]&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        self._input_helper.type_into_element(filter_textbox, filter_value, clear_first = clear_first)

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def filter_list_column(self, grid_cq: str, column_text_or_data_index: str, filter_values_to_toggle: list[str], wait_for_store_loaded: bool = True):
        &#34;&#34;&#34;Toggles the values on a list filtered column on a grid.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            filter_values_to_toggle (list[str]): The filter values to toggle.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        for filter_value_to_toggle in filter_values_to_toggle:
            self._menu_helper.click_menu_item_by_text(filter_value_to_toggle)

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def filter_number_column(self,
                             grid_cq: str,
                             column_text_or_data_index: str,
                             equal_to: Union[None, float] = None,
                             less_than: Union[None, float] = None,
                             greater_than: Union[None, float] = None,
                             wait_for_store_loaded: bool = True):
        &#34;&#34;&#34;Filters a number column on a grid for the specified values.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            filter_values_to_toggle (list[str]): The filter values to toggle.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        filter_textboxes = self._cq.wait_for_query(&#39;textfield[emptyText=&#34;Enter Number...&#34;]&#39;)

        # clear_first does not work with these :/
        # Double-clicking then either typing or deleting should do it.
        self._action_chains.move_to_element(filter_textboxes[0])
        self._action_chains.double_click()
        self._action_chains.perform()

        if less_than is not None:
            self._input_helper.type_into_element(filter_textboxes[0], less_than, clear_first = False)
        else:
            self._input_helper.type_delete()

        self._action_chains.move_to_element(filter_textboxes[1])
        self._action_chains.double_click()
        self._action_chains.perform()

        if greater_than is not None:
            self._input_helper.type_into_element(filter_textboxes[1], greater_than, clear_first = False)
        else:
            self._input_helper.type_delete()

        self._action_chains.move_to_element(filter_textboxes[2])
        self._action_chains.double_click()
        self._action_chains.perform()

        if equal_to is not None:
            self._input_helper.type_into_element(filter_textboxes[2], equal_to, clear_first = False)
        else:
            self._input_helper.type_delete()

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def toggle_column_filter(self, grid_cq: str, column_text_or_data_index: str, wait_for_store_loaded: bool = True):
        &#34;&#34;&#34;Toggles the filter on a column by clicking on the filters element.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column.
            wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
        &#34;&#34;&#34;
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)
        filter_menu_item = self._menu_helper.try_get_menu_item_by_text(&#39;Filters&#39;)

        if wait_for_store_loaded:
            self._store_helper.reset_store_load_count(grid_cq)

        self._action_chains.move_to_element(filter_menu_item)
        self._action_chains.click()
        self._action_chains.perform()

        if wait_for_store_loaded:
            self._store_helper.wait_for_store_loaded(grid_cq)

        # Close filter and then column menu
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    def clear_selection(self, grid_cq: str):
        &#34;&#34;&#34; Clears the current selection.

        Useful if want to quickly refresh a grid without having to process all the events.
        This will only work if the grid supports deselection.

        Args:
            grid_cq (str): The component query for the grid
        &#34;&#34;&#34;
        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        self._logger.info(&#34;Clearing selection on grid with CQ &#39;%s&#39;&#34;, grid_cq)

        script = self._CLEAR_SELECTION_TEMPLATE.format(grid_cq=grid_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    def get_row(self, grid_cq: str, row_data: Union[int, dict], should_throw_exception: bool = True) -&gt; WebElement:
        &#34;&#34;&#34; Gets the element for the row with the specified data or index in the grid.

        The grid must be visible.

        Args:
            grid_cq (str): The component query for the grid
            row_data (Union[int, dict]): The row data or index for the record to be found.
            should_throw_exception (bool): Indicates whether this method should throw an exception
                                           if the row is not found. Defaults to True.

        Returns:
            WebElement: The DOM element for the row or None if not found (and not thrown)
        &#34;&#34;&#34;
        # Check grid can be found and is visible
        self._cq.wait_for_single_query_visible(grid_cq)

        script = self._GET_ROW_TEMPLATE.format(grid_cq=grid_cq, row_data=row_data)
        self.ensure_javascript_loaded()
        row = self._driver.execute_script(script)

        if row or not should_throw_exception:
            return row

        raise GridHelper.RowNotFoundException(grid_cq, row_data)

    def click_row(self, grid_cq: str, row_data: Union[int, dict]):
        &#34;&#34;&#34; Clicks the row with the specified data or index in the grid.

        The grid must be visible.

        Args:
            grid_cq (str): The component query for the grid
            row_data (Union[int, dict]): The row data or index for the record to be found and clicked.
        &#34;&#34;&#34;
        # Check grid can be found and is visible
        row = self.get_row(grid_cq, row_data)

        self._logger.info(&#34;Clicking clicking row &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, row_data, grid_cq)

        self._action_chains.move_to_element(row)
        self._action_chains.click()
        self._action_chains.perform()

    def wait_for_row(self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60) -&gt; WebElement:
        &#34;&#34;&#34;Waits for the specified row to appear in the grid, reloading the store until
        it is found, or until the timeout is hit.

        Args:
            grid_cq (str): The component query for the grid.
            row_data (Union[int, dict]): The row data or index of the record we are waiting for.
            timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.

        Returns:
            WebElement: The DOM element for the row
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout).until(GridHelper.RowFoundExpectation(grid_cq, row_data))
        return self.get_row(grid_cq, row_data)

    def wait_to_click_row(self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60):
        &#34;&#34;&#34;Waits for the specified row to appear in the grid, reloading the store until
        it is found, or until the timeout is hit.
        Once we have found the row it is clicked.

        Args:
            grid_cq (str): The component query for the grid.
            row_data (Union[int, dict]): The row data or index of the record we are waiting for.
            timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout).until(GridHelper.RowFoundExpectation(grid_cq, row_data))
        self.click_row(grid_cq, row_data)

    def toggle_columns(self, grid_cq: str, column_text_or_data_index: str, columns_to_toggle: list[str]):
        &#34;&#34;&#34;Toggles a list of columns on the specified grid.
        Any that are visible will be hidden, and any that a currently hidden will be shown.

        Args:
            grid_cq (str): The component query for the owning grid.
            column_text_or_data_index (str): The header text or dataIndex of the grid column to use for the interaction.
            columns_to_toggle (list[str]): The list of columns to toggle.
        &#34;&#34;&#34;

        # Use first visible column for our interaction
        self.click_column_header_trigger(grid_cq, column_text_or_data_index)

        # Get the &#39;Columns&#39; menu itema and move to it, so that submenu shows.
        filter_menu_item = self._menu_helper.try_get_menu_item_by_text(&#39;Columns&#39;)
        self._action_chains.move_to_element(filter_menu_item)
        self._action_chains.perform()

        for column in columns_to_toggle:
            # FIXME: If column is off the bottom of the list this&#39;ll blow up...
            column_to_click = self._cq.wait_for_single_query_visible(f&#39;menucheckitem[text=&#34;{column}&#34;]&#39;)

            self._action_chains.move_to_element(column_to_click)
            self._action_chains.pause(random.uniform(self._input_helper.INPUT_SLEEP_MINIMUM, self._input_helper.INPUT_SLEEP_MAXIMUM))
            self._action_chains.click()
            self._action_chains.pause(random.uniform(self._input_helper.INPUT_SLEEP_MINIMUM, self._input_helper.INPUT_SLEEP_MAXIMUM))
            self._action_chains.perform()

        # Close columns submenu, and grid menu.
        self._input_helper.type_escape()
        self._input_helper.type_escape()

    class ColumnNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we failed to find the specified column&#34;&#34;&#34;

        def __init__(self,
                     grid_cq: str,
                     column_text_or_data_index: str,
                     message: str = &#34;Failed to find column with text (or dataIndex) &#39;{column_text_or_data_index}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                grid_cq (str): The CQ used to find the grid
                column_text_or_data_index (str): The header text or dataIndex of the grid column
                message (str, optional): The exception message. Defaults to &#34;Failed to find column with text (or dataIndex) &#39;{column_text_or_data_index}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._grid_cq = grid_cq
            self._column_text_or_data_index = column_text_or_data_index

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(column_text_or_data_index=self._column_text_or_data_index, grid_cq=self._grid_cq)

    class RowNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we failed to find the specified row&#34;&#34;&#34;

        def __init__(self,
                     grid_cq: str,
                     row_data: Union[int, dict],
                     message: str = &#34;Failed to find row with data (or index) &#39;{row_data}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                grid_cq (str): The CQ used to find the grid
                row_data (Union[int, dict]): The row data or index for the record
                message (str, optional): The exception message. Defaults to &#34;Failed to find row with data (or index) &#39;{row_data}&#39; on grid with CQ &#39;{grid_cq}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._grid_cq = grid_cq
            self._row_data = row_data

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(row_data=self._row_data, grid_cq=self._grid_cq)

    class RowFoundExpectation:
        &#34;&#34;&#34; An expectation for checking that a row has been found&#34;&#34;&#34;

        def __init__(self, grid_cq: str, row_data: Union[int, dict]):
            &#34;&#34;&#34;Initialises an instance of this class.

            Args:
                grid_cq (str): The component query for the grid.
                row_data (Union[int, dict]): The row data or index of the record we are waiting for.
            &#34;&#34;&#34;
            self._grid_cq = grid_cq
            self._row_data = row_data

        def __call__(self, driver):
            &#34;&#34;&#34;Method that determines whether a row was found.

            If the row is not found the grid is refreshed and the load waited for.
            &#34;&#34;&#34;
            grid_helper = GridHelper(driver)

            row = grid_helper.get_row(self._grid_cq, self._row_data, False)
            if row:
                return True

            # Trigger a reload, and wait for it to complete
            store_helper = StoreHelper(driver)
            store_helper.reset_store_load_count(self._grid_cq)
            store_helper.trigger_reload(self._grid_cq)
            store_helper.wait_for_store_loaded(self._grid_cq)
            return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript">HasReferencedJavaScript</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyseext.grid_helper.GridHelper.ColumnNotFoundException"><code class="name">var <span class="ident">ColumnNotFoundException</span></code></dt>
<dd>
<div class="desc"><p>Exception class thrown when we failed to find the specified column</p></div>
</dd>
<dt id="pyseext.grid_helper.GridHelper.GRID_CQ"><code class="name">var <span class="ident">GRID_CQ</span> : str</code></dt>
<dd>
<div class="desc"><p>The component query to use to find a grid panel</p></div>
</dd>
<dt id="pyseext.grid_helper.GridHelper.RowFoundExpectation"><code class="name">var <span class="ident">RowFoundExpectation</span></code></dt>
<dd>
<div class="desc"><p>An expectation for checking that a row has been found</p></div>
</dd>
<dt id="pyseext.grid_helper.GridHelper.RowNotFoundException"><code class="name">var <span class="ident">RowNotFoundException</span></code></dt>
<dd>
<div class="desc"><p>Exception class thrown when we failed to find the specified row</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyseext.grid_helper.GridHelper.check_columns_are_hidden"><code class="name flex">
<span>def <span class="ident">check_columns_are_hidden</span></span>(<span>self, grid_cq: str, column_texts_or_data_indexes: list[str]) ‑> list[selenium.webdriver.remote.webelement.WebElement]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the specified columns are all hidden on the specified grid.
Throws a ColumnNotFoundException if the column does not exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_texts_or_data_indexes</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>An array containing the header text or dataIndex of the grid columns to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An array of columns that are not hidden, if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_columns_are_hidden(self, grid_cq: str, column_texts_or_data_indexes: list[str]) -&gt; list[WebElement]:
    &#34;&#34;&#34;Checks that the specified columns are all hidden on the specified grid.
    Throws a ColumnNotFoundException if the column does not exist.

    Args:
        grid_cq (str): The component query for the owning grid
        column_texts_or_data_indexes (list[str]): An array containing the header text or dataIndex of the grid columns to check

    Returns:
        An array of columns that are not hidden, if any.
    &#34;&#34;&#34;
    column_not_hidden = []

    for column_text_or_data_index in column_texts_or_data_indexes:
        is_hidden = self.is_column_hidden(grid_cq, column_text_or_data_index)
        if not is_hidden:
            column_not_hidden.append(column_text_or_data_index)

    return column_not_hidden</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.check_columns_are_visible"><code class="name flex">
<span>def <span class="ident">check_columns_are_visible</span></span>(<span>self, grid_cq: str, column_text_or_data_indexes: list[str]) ‑> list[selenium.webdriver.remote.webelement.WebElement]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the specified columns are all visible on the specified grid.
Throws a ColumnNotFoundException if the column does not exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_text_or_data_indexes</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>An array containing the header text or dataIndex of the grid columns to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An array of columns that are not visible, if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_columns_are_visible(self, grid_cq: str, column_text_or_data_indexes: list[str]) -&gt; list[WebElement]:
    &#34;&#34;&#34;Checks that the specified columns are all visible on the specified grid.
    Throws a ColumnNotFoundException if the column does not exist.

    Args:
        grid_cq (str): The component query for the owning grid
        column_text_or_data_indexes (list[str]): An array containing the header text or dataIndex of the grid columns to check

    Returns:
        An array of columns that are not visible, if any.
    &#34;&#34;&#34;
    columns_not_visible = []

    for column_text_or_data_index in column_text_or_data_indexes:
        is_visible = self.is_column_visible(grid_cq, column_text_or_data_index)
        if not is_visible:
            columns_not_visible.append(column_text_or_data_index)

    return columns_not_visible</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.clear_selection"><code class="name flex">
<span>def <span class="ident">clear_selection</span></span>(<span>self, grid_cq: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the current selection.</p>
<p>Useful if want to quickly refresh a grid without having to process all the events.
This will only work if the grid supports deselection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the grid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_selection(self, grid_cq: str):
    &#34;&#34;&#34; Clears the current selection.

    Useful if want to quickly refresh a grid without having to process all the events.
    This will only work if the grid supports deselection.

    Args:
        grid_cq (str): The component query for the grid
    &#34;&#34;&#34;
    # Check grid can be found and is visible
    self._cq.wait_for_single_query_visible(grid_cq)

    self._logger.info(&#34;Clearing selection on grid with CQ &#39;%s&#39;&#34;, grid_cq)

    script = self._CLEAR_SELECTION_TEMPLATE.format(grid_cq=grid_cq)
    self.ensure_javascript_loaded()
    self._driver.execute_script(script)</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.click_column_header"><code class="name flex">
<span>def <span class="ident">click_column_header</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Clicks on the specified column header.
The column must be visible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_column_header(self, grid_cq: str, column_text_or_data_index: str):
    &#34;&#34;&#34;Clicks on the specified column header.
    The column must be visible.

    Args:
        grid_cq (str): The component query for the owning grid
        column_text_or_data_index (str): The header text or dataIndex of the grid column
    &#34;&#34;&#34;
    column_header = self.get_column_header(grid_cq, column_text_or_data_index)

    self._logger.info(&#34;Clicking column header &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, column_text_or_data_index, grid_cq)

    self._action_chains.move_to_element(column_header)
    self._action_chains.click()
    self._action_chains.perform()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.click_column_header_trigger"><code class="name flex">
<span>def <span class="ident">click_column_header_trigger</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Clicks on the specified column header's trigger</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_column_header_trigger(self, grid_cq: str, column_text_or_data_index: str):
    &#34;&#34;&#34;Clicks on the specified column header&#39;s trigger

    Args:
        grid_cq (str): The component query for the owning grid
        column_text_or_data_index (str): The header text or dataIndex of the grid column
    &#34;&#34;&#34;
    # We need to move to the header before the trigger becomes interactable
    column_header = self.get_column_header(grid_cq, column_text_or_data_index)
    self._action_chains.move_to_element(column_header).perform()

    column_header_trigger = self.get_column_header_trigger(grid_cq, column_text_or_data_index)

    self._logger.info(&#34;Clicking column header trigger &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, column_text_or_data_index, grid_cq)

    self._action_chains.move_to_element(column_header_trigger)
    self._action_chains.click()
    self._action_chains.perform()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.click_row"><code class="name flex">
<span>def <span class="ident">click_row</span></span>(<span>self, grid_cq: str, row_data: Union[int, dict])</span>
</code></dt>
<dd>
<div class="desc"><p>Clicks the row with the specified data or index in the grid.</p>
<p>The grid must be visible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the grid</dd>
<dt><strong><code>row_data</code></strong> :&ensp;<code>Union[int, dict]</code></dt>
<dd>The row data or index for the record to be found and clicked.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_row(self, grid_cq: str, row_data: Union[int, dict]):
    &#34;&#34;&#34; Clicks the row with the specified data or index in the grid.

    The grid must be visible.

    Args:
        grid_cq (str): The component query for the grid
        row_data (Union[int, dict]): The row data or index for the record to be found and clicked.
    &#34;&#34;&#34;
    # Check grid can be found and is visible
    row = self.get_row(grid_cq, row_data)

    self._logger.info(&#34;Clicking clicking row &#39;%s&#39; on grid with CQ &#39;%s&#39;&#34;, row_data, grid_cq)

    self._action_chains.move_to_element(row)
    self._action_chains.click()
    self._action_chains.perform()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.filter_list_column"><code class="name flex">
<span>def <span class="ident">filter_list_column</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str, filter_values_to_toggle: list[str], wait_for_store_loaded: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles the values on a list filtered column on a grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid.</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column.</dd>
<dt><strong><code>filter_values_to_toggle</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The filter values to toggle.</dd>
<dt><strong><code>wait_for_store_loaded</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether to wait for the store to load. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_list_column(self, grid_cq: str, column_text_or_data_index: str, filter_values_to_toggle: list[str], wait_for_store_loaded: bool = True):
    &#34;&#34;&#34;Toggles the values on a list filtered column on a grid.

    Args:
        grid_cq (str): The component query for the owning grid.
        column_text_or_data_index (str): The header text or dataIndex of the grid column.
        filter_values_to_toggle (list[str]): The filter values to toggle.
        wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
    &#34;&#34;&#34;
    self.click_column_header_trigger(grid_cq, column_text_or_data_index)
    self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

    if wait_for_store_loaded:
        self._store_helper.reset_store_load_count(grid_cq)

    for filter_value_to_toggle in filter_values_to_toggle:
        self._menu_helper.click_menu_item_by_text(filter_value_to_toggle)

    if wait_for_store_loaded:
        self._store_helper.wait_for_store_loaded(grid_cq)

    # Close filter and then column menu
    self._input_helper.type_escape()
    self._input_helper.type_escape()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.filter_number_column"><code class="name flex">
<span>def <span class="ident">filter_number_column</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str, equal_to: Optional[None] = None, less_than: Optional[None] = None, greater_than: Optional[None] = None, wait_for_store_loaded: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Filters a number column on a grid for the specified values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid.</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column.</dd>
<dt><strong><code>filter_values_to_toggle</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The filter values to toggle.</dd>
<dt><strong><code>wait_for_store_loaded</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether to wait for the store to load. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_number_column(self,
                         grid_cq: str,
                         column_text_or_data_index: str,
                         equal_to: Union[None, float] = None,
                         less_than: Union[None, float] = None,
                         greater_than: Union[None, float] = None,
                         wait_for_store_loaded: bool = True):
    &#34;&#34;&#34;Filters a number column on a grid for the specified values.

    Args:
        grid_cq (str): The component query for the owning grid.
        column_text_or_data_index (str): The header text or dataIndex of the grid column.
        filter_values_to_toggle (list[str]): The filter values to toggle.
        wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
    &#34;&#34;&#34;
    self.click_column_header_trigger(grid_cq, column_text_or_data_index)
    self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

    if wait_for_store_loaded:
        self._store_helper.reset_store_load_count(grid_cq)

    filter_textboxes = self._cq.wait_for_query(&#39;textfield[emptyText=&#34;Enter Number...&#34;]&#39;)

    # clear_first does not work with these :/
    # Double-clicking then either typing or deleting should do it.
    self._action_chains.move_to_element(filter_textboxes[0])
    self._action_chains.double_click()
    self._action_chains.perform()

    if less_than is not None:
        self._input_helper.type_into_element(filter_textboxes[0], less_than, clear_first = False)
    else:
        self._input_helper.type_delete()

    self._action_chains.move_to_element(filter_textboxes[1])
    self._action_chains.double_click()
    self._action_chains.perform()

    if greater_than is not None:
        self._input_helper.type_into_element(filter_textboxes[1], greater_than, clear_first = False)
    else:
        self._input_helper.type_delete()

    self._action_chains.move_to_element(filter_textboxes[2])
    self._action_chains.double_click()
    self._action_chains.perform()

    if equal_to is not None:
        self._input_helper.type_into_element(filter_textboxes[2], equal_to, clear_first = False)
    else:
        self._input_helper.type_delete()

    if wait_for_store_loaded:
        self._store_helper.wait_for_store_loaded(grid_cq)

    # Close filter and then column menu
    self._input_helper.type_escape()
    self._input_helper.type_escape()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.filter_string_column"><code class="name flex">
<span>def <span class="ident">filter_string_column</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str, filter_value: str, wait_for_store_loaded: bool = True, clear_first: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Filters a string column on a grid for the specified value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid.</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column.</dd>
<dt><strong><code>filter_value</code></strong> :&ensp;<code>str</code></dt>
<dd>The value to filter the column by.</dd>
<dt><strong><code>wait_for_store_loaded</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether to wait for the store to load. Defaults to True.</dd>
<dt><strong><code>clear_first</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether to clear the filter element first. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_string_column(self, grid_cq: str, column_text_or_data_index: str, filter_value: str, wait_for_store_loaded: bool = True, clear_first: bool = False):
    &#34;&#34;&#34;Filters a string column on a grid for the specified value.

    Args:
        grid_cq (str): The component query for the owning grid.
        column_text_or_data_index (str): The header text or dataIndex of the grid column.
        filter_value (str): The value to filter the column by.
        wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
        clear_first (bool, optional): Indicates whether to clear the filter element first. Defaults to False.
    &#34;&#34;&#34;
    self.click_column_header_trigger(grid_cq, column_text_or_data_index)
    self._menu_helper.move_to_menu_item_by_text(&#39;Filters&#39;)

    filter_textbox = self._cq.wait_for_single_query_visible(&#39;textfield[emptyText=&#34;Enter Filter Text...&#34;]&#39;)

    if wait_for_store_loaded:
        self._store_helper.reset_store_load_count(grid_cq)

    self._input_helper.type_into_element(filter_textbox, filter_value, clear_first = clear_first)

    if wait_for_store_loaded:
        self._store_helper.wait_for_store_loaded(grid_cq)

    # Close filter and then column menu
    self._input_helper.type_escape()
    self._input_helper.type_escape()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.get_column_header"><code class="name flex">
<span>def <span class="ident">get_column_header</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the element for the specified column header</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the column header</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_header(self, grid_cq: str, column_text_or_data_index: str) -&gt; WebElement:
    &#34;&#34;&#34;Gets the element for the specified column header

    Args:
        grid_cq (str): The component query for the owning grid
        column_text_or_data_index (str): The header text or dataIndex of the grid column

    Returns:
        WebElement: The DOM element for the column header
    &#34;&#34;&#34;

    # Check grid can be found and is visible
    self._cq.wait_for_single_query_visible(grid_cq)

    script = self._GET_COLUMN_HEADER_TEMPLATE.format(grid_cq=grid_cq, column_text_or_data_index=column_text_or_data_index)
    self.ensure_javascript_loaded()
    column_header = self._driver.execute_script(script)

    if column_header:
        return column_header

    raise GridHelper.ColumnNotFoundException(grid_cq, column_text_or_data_index)</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.get_column_header_trigger"><code class="name flex">
<span>def <span class="ident">get_column_header_trigger</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the element for the specified column header's trigger</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the column header trigger.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_header_trigger(self, grid_cq: str, column_text_or_data_index: str) -&gt; WebElement:
    &#34;&#34;&#34;Gets the element for the specified column header&#39;s trigger

    Args:
        grid_cq (str): The component query for the owning grid
        column_text_or_data_index (str): The header text or dataIndex of the grid column

    Returns:
        WebElement: The DOM element for the column header trigger.
    &#34;&#34;&#34;

    # Check grid can be found and is visible
    self._cq.wait_for_single_query_visible(grid_cq)

    script = self._GET_COLUMN_HEADER_TRIGGER_TEMPLATE.format(grid_cq=grid_cq, column_text_or_data_index=column_text_or_data_index)
    self.ensure_javascript_loaded()
    column_header_trigger = self._driver.execute_script(script)

    if column_header_trigger:
        return column_header_trigger

    raise GridHelper.ColumnNotFoundException(grid_cq, column_text_or_data_index)</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.get_row"><code class="name flex">
<span>def <span class="ident">get_row</span></span>(<span>self, grid_cq: str, row_data: Union[int, dict], should_throw_exception: bool = True) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the element for the row with the specified data or index in the grid.</p>
<p>The grid must be visible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the grid</dd>
<dt><strong><code>row_data</code></strong> :&ensp;<code>Union[int, dict]</code></dt>
<dd>The row data or index for the record to be found.</dd>
<dt><strong><code>should_throw_exception</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether this method should throw an exception
if the row is not found. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the row or None if not found (and not thrown)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_row(self, grid_cq: str, row_data: Union[int, dict], should_throw_exception: bool = True) -&gt; WebElement:
    &#34;&#34;&#34; Gets the element for the row with the specified data or index in the grid.

    The grid must be visible.

    Args:
        grid_cq (str): The component query for the grid
        row_data (Union[int, dict]): The row data or index for the record to be found.
        should_throw_exception (bool): Indicates whether this method should throw an exception
                                       if the row is not found. Defaults to True.

    Returns:
        WebElement: The DOM element for the row or None if not found (and not thrown)
    &#34;&#34;&#34;
    # Check grid can be found and is visible
    self._cq.wait_for_single_query_visible(grid_cq)

    script = self._GET_ROW_TEMPLATE.format(grid_cq=grid_cq, row_data=row_data)
    self.ensure_javascript_loaded()
    row = self._driver.execute_script(script)

    if row or not should_throw_exception:
        return row

    raise GridHelper.RowNotFoundException(grid_cq, row_data)</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.is_column_hidden"><code class="name flex">
<span>def <span class="ident">is_column_hidden</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the specified column is hidden.
Throws a ColumnNotFoundException if the column does not exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the column is hidden, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_column_hidden(self, grid_cq: str, column_text_or_data_index: str) -&gt; bool:
    &#34;&#34;&#34;Determines whether the specified column is hidden.
    Throws a ColumnNotFoundException if the column does not exist.

    Args:
        grid_cq (str): The component query for the owning grid
        column_text_or_data_index (str): The header text or dataIndex of the grid column

    Returns:
        True if the column is hidden, False otherwise.
    &#34;&#34;&#34;
    return not self.get_column_header(grid_cq, column_text_or_data_index).is_displayed()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.is_column_visible"><code class="name flex">
<span>def <span class="ident">is_column_visible</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the specified column is visible,
Throws a ColumnNotFoundException if the column does not exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the column is visible, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_column_visible(self, grid_cq: str, column_text_or_data_index: str) -&gt; bool:
    &#34;&#34;&#34;Determines whether the specified column is visible,
    Throws a ColumnNotFoundException if the column does not exist.

    Args:
        grid_cq (str): The component query for the owning grid
        column_text_or_data_index (str): The header text or dataIndex of the grid column

    Returns:
        True if the column is visible, False otherwise.
    &#34;&#34;&#34;
    return self.get_column_header(grid_cq, column_text_or_data_index).is_displayed()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.toggle_column_filter"><code class="name flex">
<span>def <span class="ident">toggle_column_filter</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str, wait_for_store_loaded: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles the filter on a column by clicking on the filters element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid.</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column.</dd>
<dt><strong><code>wait_for_store_loaded</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether to wait for the store to load. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_column_filter(self, grid_cq: str, column_text_or_data_index: str, wait_for_store_loaded: bool = True):
    &#34;&#34;&#34;Toggles the filter on a column by clicking on the filters element.

    Args:
        grid_cq (str): The component query for the owning grid.
        column_text_or_data_index (str): The header text or dataIndex of the grid column.
        wait_for_store_loaded (bool, optional): Indicates whether to wait for the store to load. Defaults to True.
    &#34;&#34;&#34;
    self.click_column_header_trigger(grid_cq, column_text_or_data_index)
    filter_menu_item = self._menu_helper.try_get_menu_item_by_text(&#39;Filters&#39;)

    if wait_for_store_loaded:
        self._store_helper.reset_store_load_count(grid_cq)

    self._action_chains.move_to_element(filter_menu_item)
    self._action_chains.click()
    self._action_chains.perform()

    if wait_for_store_loaded:
        self._store_helper.wait_for_store_loaded(grid_cq)

    # Close filter and then column menu
    self._input_helper.type_escape()
    self._input_helper.type_escape()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.toggle_columns"><code class="name flex">
<span>def <span class="ident">toggle_columns</span></span>(<span>self, grid_cq: str, column_text_or_data_index: str, columns_to_toggle: list[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles a list of columns on the specified grid.
Any that are visible will be hidden, and any that a currently hidden will be shown.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the owning grid.</dd>
<dt><strong><code>column_text_or_data_index</code></strong> :&ensp;<code>str</code></dt>
<dd>The header text or dataIndex of the grid column to use for the interaction.</dd>
<dt><strong><code>columns_to_toggle</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The list of columns to toggle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_columns(self, grid_cq: str, column_text_or_data_index: str, columns_to_toggle: list[str]):
    &#34;&#34;&#34;Toggles a list of columns on the specified grid.
    Any that are visible will be hidden, and any that a currently hidden will be shown.

    Args:
        grid_cq (str): The component query for the owning grid.
        column_text_or_data_index (str): The header text or dataIndex of the grid column to use for the interaction.
        columns_to_toggle (list[str]): The list of columns to toggle.
    &#34;&#34;&#34;

    # Use first visible column for our interaction
    self.click_column_header_trigger(grid_cq, column_text_or_data_index)

    # Get the &#39;Columns&#39; menu itema and move to it, so that submenu shows.
    filter_menu_item = self._menu_helper.try_get_menu_item_by_text(&#39;Columns&#39;)
    self._action_chains.move_to_element(filter_menu_item)
    self._action_chains.perform()

    for column in columns_to_toggle:
        # FIXME: If column is off the bottom of the list this&#39;ll blow up...
        column_to_click = self._cq.wait_for_single_query_visible(f&#39;menucheckitem[text=&#34;{column}&#34;]&#39;)

        self._action_chains.move_to_element(column_to_click)
        self._action_chains.pause(random.uniform(self._input_helper.INPUT_SLEEP_MINIMUM, self._input_helper.INPUT_SLEEP_MAXIMUM))
        self._action_chains.click()
        self._action_chains.pause(random.uniform(self._input_helper.INPUT_SLEEP_MINIMUM, self._input_helper.INPUT_SLEEP_MAXIMUM))
        self._action_chains.perform()

    # Close columns submenu, and grid menu.
    self._input_helper.type_escape()
    self._input_helper.type_escape()</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.wait_for_row"><code class="name flex">
<span>def <span class="ident">wait_for_row</span></span>(<span>self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Waits for the specified row to appear in the grid, reloading the store until
it is found, or until the timeout is hit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the grid.</dd>
<dt><strong><code>row_data</code></strong> :&ensp;<code>Union[int, dict]</code></dt>
<dd>The row data or index of the record we are waiting for.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of seconds to wait for the row before erroring. Defaults to 60.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the row</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_row(self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60) -&gt; WebElement:
    &#34;&#34;&#34;Waits for the specified row to appear in the grid, reloading the store until
    it is found, or until the timeout is hit.

    Args:
        grid_cq (str): The component query for the grid.
        row_data (Union[int, dict]): The row data or index of the record we are waiting for.
        timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.

    Returns:
        WebElement: The DOM element for the row
    &#34;&#34;&#34;
    WebDriverWait(self._driver, timeout).until(GridHelper.RowFoundExpectation(grid_cq, row_data))
    return self.get_row(grid_cq, row_data)</code></pre>
</details>
</dd>
<dt id="pyseext.grid_helper.GridHelper.wait_to_click_row"><code class="name flex">
<span>def <span class="ident">wait_to_click_row</span></span>(<span>self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60)</span>
</code></dt>
<dd>
<div class="desc"><p>Waits for the specified row to appear in the grid, reloading the store until
it is found, or until the timeout is hit.
Once we have found the row it is clicked.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the grid.</dd>
<dt><strong><code>row_data</code></strong> :&ensp;<code>Union[int, dict]</code></dt>
<dd>The row data or index of the record we are waiting for.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of seconds to wait for the row before erroring. Defaults to 60.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_to_click_row(self, grid_cq: str, row_data: Union[int, dict], timeout: float = 60):
    &#34;&#34;&#34;Waits for the specified row to appear in the grid, reloading the store until
    it is found, or until the timeout is hit.
    Once we have found the row it is clicked.

    Args:
        grid_cq (str): The component query for the grid.
        row_data (Union[int, dict]): The row data or index of the record we are waiting for.
        timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.
    &#34;&#34;&#34;
    WebDriverWait(self._driver, timeout).until(GridHelper.RowFoundExpectation(grid_cq, row_data))
    self.click_row(grid_cq, row_data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript">HasReferencedJavaScript</a></b></code>:
<ul class="hlist">
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.JavaScriptLoadedExpectation" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.JavaScriptLoadedExpectation">JavaScriptLoadedExpectation</a></code></li>
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.ensure_javascript_loaded" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.ensure_javascript_loaded">ensure_javascript_loaded</a></code></li>
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.get_async_script_content" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.get_async_script_content">get_async_script_content</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyseext" href="index.html">pyseext</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyseext.grid_helper.GridHelper" href="#pyseext.grid_helper.GridHelper">GridHelper</a></code></h4>
<ul class="">
<li><code><a title="pyseext.grid_helper.GridHelper.ColumnNotFoundException" href="#pyseext.grid_helper.GridHelper.ColumnNotFoundException">ColumnNotFoundException</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.GRID_CQ" href="#pyseext.grid_helper.GridHelper.GRID_CQ">GRID_CQ</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.RowFoundExpectation" href="#pyseext.grid_helper.GridHelper.RowFoundExpectation">RowFoundExpectation</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.RowNotFoundException" href="#pyseext.grid_helper.GridHelper.RowNotFoundException">RowNotFoundException</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.check_columns_are_hidden" href="#pyseext.grid_helper.GridHelper.check_columns_are_hidden">check_columns_are_hidden</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.check_columns_are_visible" href="#pyseext.grid_helper.GridHelper.check_columns_are_visible">check_columns_are_visible</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.clear_selection" href="#pyseext.grid_helper.GridHelper.clear_selection">clear_selection</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.click_column_header" href="#pyseext.grid_helper.GridHelper.click_column_header">click_column_header</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.click_column_header_trigger" href="#pyseext.grid_helper.GridHelper.click_column_header_trigger">click_column_header_trigger</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.click_row" href="#pyseext.grid_helper.GridHelper.click_row">click_row</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.filter_list_column" href="#pyseext.grid_helper.GridHelper.filter_list_column">filter_list_column</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.filter_number_column" href="#pyseext.grid_helper.GridHelper.filter_number_column">filter_number_column</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.filter_string_column" href="#pyseext.grid_helper.GridHelper.filter_string_column">filter_string_column</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.get_column_header" href="#pyseext.grid_helper.GridHelper.get_column_header">get_column_header</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.get_column_header_trigger" href="#pyseext.grid_helper.GridHelper.get_column_header_trigger">get_column_header_trigger</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.get_row" href="#pyseext.grid_helper.GridHelper.get_row">get_row</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.is_column_hidden" href="#pyseext.grid_helper.GridHelper.is_column_hidden">is_column_hidden</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.is_column_visible" href="#pyseext.grid_helper.GridHelper.is_column_visible">is_column_visible</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.toggle_column_filter" href="#pyseext.grid_helper.GridHelper.toggle_column_filter">toggle_column_filter</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.toggle_columns" href="#pyseext.grid_helper.GridHelper.toggle_columns">toggle_columns</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.wait_for_row" href="#pyseext.grid_helper.GridHelper.wait_for_row">wait_for_row</a></code></li>
<li><code><a title="pyseext.grid_helper.GridHelper.wait_to_click_row" href="#pyseext.grid_helper.GridHelper.wait_to_click_row">wait_to_click_row</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>