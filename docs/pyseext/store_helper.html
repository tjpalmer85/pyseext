<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyseext.store_helper API documentation</title>
<meta name="description" content="Module that contains our StoreHelper class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyseext.store_helper</code></h1>
</header>
<section id="section-intro">
<p>Module that contains our StoreHelper class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that contains our StoreHelper class.
&#34;&#34;&#34;
import logging

from selenium.webdriver.remote.webdriver import WebDriver

from pyseext.has_referenced_javascript import HasReferencedJavaScript

class StoreHelper(HasReferencedJavaScript):
    &#34;&#34;&#34;A class to help with using stores, through Ext&#39;s interfaces.
    &#34;&#34;&#34;

    # Class variables
    _RESET_STORE_LOAD_COUNT_TEMPLATE: str = &#34;return globalThis.PySeExt.StoreHelper.resetStoreLoadCount(&#39;{store_holder_cq}&#39;)&#34;
    _WAIT_FOR_STORE_LOADED_TEMPLATE: str = &#34;return globalThis.PySeExt.StoreHelper.waitForStoreLoaded(&#39;{store_holder_cq}&#39;, callback)&#34;
    _RELOAD_STORE_TEMPLATE: str = &#34;return globalThis.PySeExt.StoreHelper.reload(&#39;{store_holder_cq}&#39;)&#34;

    def __init__(self, driver: WebDriver):
        &#34;&#34;&#34;Initialises an instance of this class

        Args:
            driver (selenium.webdriver): The webdriver to use
        &#34;&#34;&#34;
        self._logger = logging.getLogger(__name__)
        self._driver = driver

        # Initialise our base class
        super().__init__(driver, self._logger)

    def reset_store_load_count(self, store_holder_cq: str):
        &#34;&#34;&#34;Resets the load count on the specified store, provided the store is not configured with autoLoad set to true.

        If set to auto load then this method does nothing.

        The load count on a store is incremented everytime a load occurs. It is not reset when the data is cleared.
        A store&#39;s isLoaded method returns true if the load count is greater than zero.

        Calling this method is useful to use before performing an action that will trigger a load, since you can then
        wait for the stores isLoaded method to return true.
        This is far more reliable than waiting for the load event, since it may have already been fired by the time the
        test gets that far.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        self._logger.debug(&#34;Resetting loadCount on store owned by &#39;%s&#39;&#34;, store_holder_cq)

        script = self._RESET_STORE_LOAD_COUNT_TEMPLATE.format(store_holder_cq=store_holder_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    def wait_for_store_loaded(self, store_holder_cq: str):
        &#34;&#34;&#34; Waits for the specified store to return true from its isLoaded method.

        Should generally be used after calling #resetStoreLoadCount and performing an
        action that triggers a store load.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        self._logger.debug(&#34;Waiting for store owned by &#39;%s&#39; to load&#34;, store_holder_cq)

        async_script = self.get_async_script_content(self._WAIT_FOR_STORE_LOADED_TEMPLATE).format(store_holder_cq=store_holder_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_async_script(async_script)

        self._logger.debug(&#34;Store owned by &#39;%s&#39; loaded&#34;, store_holder_cq)

    def trigger_reload(self, store_holder_cq: str):
        &#34;&#34;&#34;Triggers a reload on the specified store.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        script = self._RELOAD_STORE_TEMPLATE.format(store_holder_cq=store_holder_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    def trigger_reload_and_wait(self, store_holder_cq: str):
        &#34;&#34;&#34;Triggers a load on the specified store and waits for it to complete.

        Basically resets the store load count, triggers a reload and then waits for the store to
        show as loaded.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        self.reset_store_load_count(store_holder_cq)
        self.trigger_reload(store_holder_cq)
        self.wait_for_store_loaded(store_holder_cq)

    # FIXME: Some method ideas:
    # .....:    - check_store_contains(self, store_holder_cq: str, data: list[dict], should_only_contain_specified_data: bool = False)= &gt; bool
    # .....:        Method that checks that the store contains the specified data, and optionally only the specified data.
    # .....:        Can be used to check combobox data, say.</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyseext.store_helper.StoreHelper"><code class="flex name class">
<span>class <span class="ident">StoreHelper</span></span>
<span>(</span><span>driver: selenium.webdriver.remote.webdriver.WebDriver)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to help with using stores, through Ext's interfaces.</p>
<p>Initialises an instance of this class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>driver</code></strong> :&ensp;<code>selenium.webdriver</code></dt>
<dd>The webdriver to use</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoreHelper(HasReferencedJavaScript):
    &#34;&#34;&#34;A class to help with using stores, through Ext&#39;s interfaces.
    &#34;&#34;&#34;

    # Class variables
    _RESET_STORE_LOAD_COUNT_TEMPLATE: str = &#34;return globalThis.PySeExt.StoreHelper.resetStoreLoadCount(&#39;{store_holder_cq}&#39;)&#34;
    _WAIT_FOR_STORE_LOADED_TEMPLATE: str = &#34;return globalThis.PySeExt.StoreHelper.waitForStoreLoaded(&#39;{store_holder_cq}&#39;, callback)&#34;
    _RELOAD_STORE_TEMPLATE: str = &#34;return globalThis.PySeExt.StoreHelper.reload(&#39;{store_holder_cq}&#39;)&#34;

    def __init__(self, driver: WebDriver):
        &#34;&#34;&#34;Initialises an instance of this class

        Args:
            driver (selenium.webdriver): The webdriver to use
        &#34;&#34;&#34;
        self._logger = logging.getLogger(__name__)
        self._driver = driver

        # Initialise our base class
        super().__init__(driver, self._logger)

    def reset_store_load_count(self, store_holder_cq: str):
        &#34;&#34;&#34;Resets the load count on the specified store, provided the store is not configured with autoLoad set to true.

        If set to auto load then this method does nothing.

        The load count on a store is incremented everytime a load occurs. It is not reset when the data is cleared.
        A store&#39;s isLoaded method returns true if the load count is greater than zero.

        Calling this method is useful to use before performing an action that will trigger a load, since you can then
        wait for the stores isLoaded method to return true.
        This is far more reliable than waiting for the load event, since it may have already been fired by the time the
        test gets that far.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        self._logger.debug(&#34;Resetting loadCount on store owned by &#39;%s&#39;&#34;, store_holder_cq)

        script = self._RESET_STORE_LOAD_COUNT_TEMPLATE.format(store_holder_cq=store_holder_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    def wait_for_store_loaded(self, store_holder_cq: str):
        &#34;&#34;&#34; Waits for the specified store to return true from its isLoaded method.

        Should generally be used after calling #resetStoreLoadCount and performing an
        action that triggers a store load.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        self._logger.debug(&#34;Waiting for store owned by &#39;%s&#39; to load&#34;, store_holder_cq)

        async_script = self.get_async_script_content(self._WAIT_FOR_STORE_LOADED_TEMPLATE).format(store_holder_cq=store_holder_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_async_script(async_script)

        self._logger.debug(&#34;Store owned by &#39;%s&#39; loaded&#34;, store_holder_cq)

    def trigger_reload(self, store_holder_cq: str):
        &#34;&#34;&#34;Triggers a reload on the specified store.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        script = self._RELOAD_STORE_TEMPLATE.format(store_holder_cq=store_holder_cq)
        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    def trigger_reload_and_wait(self, store_holder_cq: str):
        &#34;&#34;&#34;Triggers a load on the specified store and waits for it to complete.

        Basically resets the store load count, triggers a reload and then waits for the store to
        show as loaded.

        Args:
            store_holder_cq (str): The component query to use to find the store holder.
        &#34;&#34;&#34;
        self.reset_store_load_count(store_holder_cq)
        self.trigger_reload(store_holder_cq)
        self.wait_for_store_loaded(store_holder_cq)

    # FIXME: Some method ideas:
    # .....:    - check_store_contains(self, store_holder_cq: str, data: list[dict], should_only_contain_specified_data: bool = False)= &gt; bool
    # .....:        Method that checks that the store contains the specified data, and optionally only the specified data.
    # .....:        Can be used to check combobox data, say.</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript">HasReferencedJavaScript</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyseext.store_helper.StoreHelper.reset_store_load_count"><code class="name flex">
<span>def <span class="ident">reset_store_load_count</span></span>(<span>self, store_holder_cq: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the load count on the specified store, provided the store is not configured with autoLoad set to true.</p>
<p>If set to auto load then this method does nothing.</p>
<p>The load count on a store is incremented everytime a load occurs. It is not reset when the data is cleared.
A store's isLoaded method returns true if the load count is greater than zero.</p>
<p>Calling this method is useful to use before performing an action that will trigger a load, since you can then
wait for the stores isLoaded method to return true.
This is far more reliable than waiting for the load event, since it may have already been fired by the time the
test gets that far.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>store_holder_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the store holder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_store_load_count(self, store_holder_cq: str):
    &#34;&#34;&#34;Resets the load count on the specified store, provided the store is not configured with autoLoad set to true.

    If set to auto load then this method does nothing.

    The load count on a store is incremented everytime a load occurs. It is not reset when the data is cleared.
    A store&#39;s isLoaded method returns true if the load count is greater than zero.

    Calling this method is useful to use before performing an action that will trigger a load, since you can then
    wait for the stores isLoaded method to return true.
    This is far more reliable than waiting for the load event, since it may have already been fired by the time the
    test gets that far.

    Args:
        store_holder_cq (str): The component query to use to find the store holder.
    &#34;&#34;&#34;
    self._logger.debug(&#34;Resetting loadCount on store owned by &#39;%s&#39;&#34;, store_holder_cq)

    script = self._RESET_STORE_LOAD_COUNT_TEMPLATE.format(store_holder_cq=store_holder_cq)
    self.ensure_javascript_loaded()
    self._driver.execute_script(script)</code></pre>
</details>
</dd>
<dt id="pyseext.store_helper.StoreHelper.trigger_reload"><code class="name flex">
<span>def <span class="ident">trigger_reload</span></span>(<span>self, store_holder_cq: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggers a reload on the specified store.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>store_holder_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the store holder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_reload(self, store_holder_cq: str):
    &#34;&#34;&#34;Triggers a reload on the specified store.

    Args:
        store_holder_cq (str): The component query to use to find the store holder.
    &#34;&#34;&#34;
    script = self._RELOAD_STORE_TEMPLATE.format(store_holder_cq=store_holder_cq)
    self.ensure_javascript_loaded()
    self._driver.execute_script(script)</code></pre>
</details>
</dd>
<dt id="pyseext.store_helper.StoreHelper.trigger_reload_and_wait"><code class="name flex">
<span>def <span class="ident">trigger_reload_and_wait</span></span>(<span>self, store_holder_cq: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggers a load on the specified store and waits for it to complete.</p>
<p>Basically resets the store load count, triggers a reload and then waits for the store to
show as loaded.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>store_holder_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the store holder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_reload_and_wait(self, store_holder_cq: str):
    &#34;&#34;&#34;Triggers a load on the specified store and waits for it to complete.

    Basically resets the store load count, triggers a reload and then waits for the store to
    show as loaded.

    Args:
        store_holder_cq (str): The component query to use to find the store holder.
    &#34;&#34;&#34;
    self.reset_store_load_count(store_holder_cq)
    self.trigger_reload(store_holder_cq)
    self.wait_for_store_loaded(store_holder_cq)</code></pre>
</details>
</dd>
<dt id="pyseext.store_helper.StoreHelper.wait_for_store_loaded"><code class="name flex">
<span>def <span class="ident">wait_for_store_loaded</span></span>(<span>self, store_holder_cq: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Waits for the specified store to return true from its isLoaded method.</p>
<p>Should generally be used after calling #resetStoreLoadCount and performing an
action that triggers a store load.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>store_holder_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the store holder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_store_loaded(self, store_holder_cq: str):
    &#34;&#34;&#34; Waits for the specified store to return true from its isLoaded method.

    Should generally be used after calling #resetStoreLoadCount and performing an
    action that triggers a store load.

    Args:
        store_holder_cq (str): The component query to use to find the store holder.
    &#34;&#34;&#34;
    self._logger.debug(&#34;Waiting for store owned by &#39;%s&#39; to load&#34;, store_holder_cq)

    async_script = self.get_async_script_content(self._WAIT_FOR_STORE_LOADED_TEMPLATE).format(store_holder_cq=store_holder_cq)
    self.ensure_javascript_loaded()
    self._driver.execute_async_script(async_script)

    self._logger.debug(&#34;Store owned by &#39;%s&#39; loaded&#34;, store_holder_cq)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript">HasReferencedJavaScript</a></b></code>:
<ul class="hlist">
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.JavaScriptLoadedExpectation" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.JavaScriptLoadedExpectation">JavaScriptLoadedExpectation</a></code></li>
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.ensure_javascript_loaded" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.ensure_javascript_loaded">ensure_javascript_loaded</a></code></li>
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.get_async_script_content" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.get_async_script_content">get_async_script_content</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyseext" href="index.html">pyseext</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyseext.store_helper.StoreHelper" href="#pyseext.store_helper.StoreHelper">StoreHelper</a></code></h4>
<ul class="">
<li><code><a title="pyseext.store_helper.StoreHelper.reset_store_load_count" href="#pyseext.store_helper.StoreHelper.reset_store_load_count">reset_store_load_count</a></code></li>
<li><code><a title="pyseext.store_helper.StoreHelper.trigger_reload" href="#pyseext.store_helper.StoreHelper.trigger_reload">trigger_reload</a></code></li>
<li><code><a title="pyseext.store_helper.StoreHelper.trigger_reload_and_wait" href="#pyseext.store_helper.StoreHelper.trigger_reload_and_wait">trigger_reload_and_wait</a></code></li>
<li><code><a title="pyseext.store_helper.StoreHelper.wait_for_store_loaded" href="#pyseext.store_helper.StoreHelper.wait_for_store_loaded">wait_for_store_loaded</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>