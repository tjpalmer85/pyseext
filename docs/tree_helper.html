<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyseext.tree_helper API documentation</title>
<meta name="description" content="Module that contains our TreeHelper class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyseext.tree_helper</code></h1>
</header>
<section id="section-intro">
<p>Module that contains our TreeHelper class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that contains our TreeHelper class.
&#34;&#34;&#34;
import logging
import time
from typing import Union
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.remote.webelement import WebElement

from pyseext.has_referenced_javascript import HasReferencedJavaScript
from pyseext.core import Core
from pyseext.menu_helper import MenuHelper

class TreeHelper(HasReferencedJavaScript):
    &#34;&#34;&#34;A class to help with using trees, through Ext&#39;s interfaces.&#34;&#34;&#34;

    # Class variables
    _IS_TREE_LOADING_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.isTreeLoading(&#39;{tree_cq}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.isTreeLoading
    Requires the inserts: {tree_cq}&#34;&#34;&#34;

    _GET_NODE_ELEMENT_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.getNodeElement(&#39;{tree_cq}&#39;, {node_text_or_data}, &#39;{css_query}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.getNodeElement
    Requires the inserts: {tree_cq}, {node_text_or_data}, {css_query}&#34;&#34;&#34;

    _GET_NODE_ELEMENT_WITH_ROOT_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.getNodeElement(&#39;{tree_cq}&#39;, {node_text_or_data}, &#39;{css_query}&#39;, {root_node_text_or_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.getNodeElement including a root node to search from
    Requires the inserts: {tree_cq}, {node_text_or_data}, {css_query}, {root_node_text_or_data}&#34;&#34;&#34;

    _RELOAD_NODE_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.reloadNode(&#39;{tree_cq}&#39;, {node_text_or_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.reloadNode
    Requires the inserts: {tree_cq}, {node_text_or_data}&#34;&#34;&#34;

    _RELOAD_NODE_WITH_ROOT_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.reloadNode(&#39;{tree_cq}&#39;, {node_text_or_data}, {root_node_text_or_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.reloadNode including a root node to search from
    Requires the inserts: {tree_cq}, {node_text_or_data}, {root_node_text_or_data}&#34;&#34;&#34;

    _ICON_CSS_SELECTOR: str = &#34;.x-tree-icon&#34;
    &#34;&#34;&#34;The CSS selector to use with get_node_element to find the node icon element.
    &#34;&#34;&#34;

    _EXPANDER_CSS_SELECTOR: str = &#34;.x-tree-expander&#34;
    &#34;&#34;&#34;The CSS selector to use with get_node_element to find the node expander element.
    &#34;&#34;&#34;

    _NODE_TEXT_CSS_SELECTOR: str = &#34;.x-tree-node-text&#34;
    &#34;&#34;&#34;The CSS selector to use with get_node_element to find the node text element.
    &#34;&#34;&#34;

    def __init__(self, driver: WebDriver):
        &#34;&#34;&#34;Initialises an instance of this class

        Args:
            driver (WebDriver): The webdriver to use
        &#34;&#34;&#34;
        self._logger = logging.getLogger(__name__)
        &#34;&#34;&#34;The Logger instance for this class instance&#34;&#34;&#34;

        self._driver = driver
        &#34;&#34;&#34;The WebDriver instance for this class instance&#34;&#34;&#34;

        self._action_chains = ActionChains(driver)
        &#34;&#34;&#34;The ActionChains instance for this class instance&#34;&#34;&#34;

        self._core = Core(driver)
        &#34;&#34;&#34;The `Core` instance for this class instance&#34;&#34;&#34;

        self._menu_helper = MenuHelper(driver)
        &#34;&#34;&#34;The `MenuHelper` instance for this class instance&#34;&#34;&#34;

        # Initialise our base class
        super().__init__(driver, self._logger)

    def is_tree_loading(self, tree_cq: str):
        &#34;&#34;&#34;Determine whether the tree (any part of it) is currently loading.

        You should call this before calling any tree interaction methods,
        since we cannot pass things back in callbacks!

        Args:
            tree_cq (str): The component query to use to find the tree.

        Returns:
            bool: True if the tree is loaded, False otherwise.
        &#34;&#34;&#34;
        script = self._IS_TREE_LOADING_TEMPLATE.format(tree_cq=tree_cq)
        self.ensure_javascript_loaded()
        return self._driver.execute_script(script)

    def wait_until_tree_not_loading(self,
                                    tree_cq: str,
                                    timeout: float = 30,
                                    poll_frequecy: float = 0.2,
                                    recheck_time_if_false: float = 0.2):
        &#34;&#34;&#34;Waits until the tree identified by the component query is not loading,
        or the timeout is hit

        Args:
            tree_cq (str): The component query for the tree.
            timeout (float, optional): The number of seconds to wait before erroring. Defaults to 30.
            poll_frequency (float, optional): Number of seconds to poll. Defaults to 0.2.
            recheck_time_if_false (float, optional): If we get a result such that no Ajax calls are in progress, this is the amount of time to wait to check again. Defaults to 0.2.
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout, poll_frequency = poll_frequecy).until(TreeHelper.TreeNotLoadingExpectation(tree_cq, recheck_time_if_false))

    def get_node_icon_element(self,
                              tree_cq: str,
                              node_text_or_data: Union[str, dict],
                              root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s icon.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node icon.
        &#34;&#34;&#34;
        return self.get_node_element(tree_cq, node_text_or_data, self._ICON_CSS_SELECTOR, root_node_text_or_data)

    def get_node_text_element(self,
                              tree_cq: str,
                              node_text_or_data: Union[str, dict],
                              root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s text.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node text.
        &#34;&#34;&#34;
        return self.get_node_element(tree_cq, node_text_or_data, self._NODE_TEXT_CSS_SELECTOR, root_node_text_or_data)

    def get_node_expander_element(self,
                                  tree_cq: str,
                                  node_text_or_data: Union[str, dict],
                                  root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s expander UI element.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node&#39;s expander.
        &#34;&#34;&#34;
        return self.get_node_element(tree_cq, node_text_or_data, self._EXPANDER_CSS_SELECTOR, root_node_text_or_data)

    def get_node_element(self,
                         tree_cq: str,
                         node_text_or_data: Union[str, dict],
                         css_query: str,
                         root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            css_query (str): The CSS to query for in the found node row element.
                             Some expected ones:
                                Expander UI element = &#39;.x-tree-expander&#39;
                                Node icon = &#39;.x-tree-icon&#39;
                                Node text = &#39;.x-tree-node-text&#39;
                             If need those you&#39;d use one of the other methods though.
                             This is in case need to click on another part of the node&#39;s row.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node&#39;s expander.
        &#34;&#34;&#34;
        self.wait_until_tree_not_loading(tree_cq)

        if isinstance(node_text_or_data, str):
            node_text_or_data = f&#34;&#39;{node_text_or_data}&#39;&#34;

        if isinstance(root_node_text_or_data, str):
            root_node_text_or_data = f&#34;&#39;{root_node_text_or_data}&#39;&#34;

        if root_node_text_or_data:
            script = self._GET_NODE_ELEMENT_WITH_ROOT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, css_query=css_query, root_node_text_or_data=root_node_text_or_data)
        else:
            script = self._GET_NODE_ELEMENT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, css_query=css_query)

        self.ensure_javascript_loaded()
        return self._driver.execute_script(script)

    def open_node_context_menu(self,
                               tree_cq: str,
                               node_text_or_data: Union[str, dict],
                               root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node&#39;s icon element by text or data, then right clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        self.context_click_node_element(tree_cq, node_text_or_data, self._ICON_CSS_SELECTOR, root_node_text_or_data)

    def check_node_context_menu_contains_items(self,
                                               tree_cq: str,
                                               node_text_or_data: Union[str, dict],
                                               expected_items: list[str],
                                               check_contains_no_additional_items: bool = True,
                                               ignore_spacers: bool = False,
                                               root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Opens the context menu for a node, and checks that it contains the specified items.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            expected_items (list[str]): A list of menu items (text) that we&#39;re expecting to find.
                                        Spacers have text containing of a single space (MenuHelper.SPACER_TEXT_CONTEXT), but can be ignored using ignore_spacers if desired.
                                        e.g. [&#39;Add&#39;, &#39;Edit&#39;, &#39;Delete&#39;, MenuHelper.SPACER_TEXT_CONTEXT, &#39;Refresh&#39;]
            check_contains_no_additional_items (bool, optional): Indicates whether we should check that there are no additional items in the menu.
                                                                 Defaults to True.
            ignore_spacers (bool, optional): Indicates whether we should include spacers in our checks. Defaults to False.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        self.open_node_context_menu(tree_cq, node_text_or_data, root_node_text_or_data)

        unexpected_items: list[str] = []

        # Get all menu items
        menu_items = self._menu_helper.get_enabled_menu_items()

        # Each element has a text member we can compare.
        for item in menu_items:
            if ignore_spacers is True and item.text == MenuHelper.SPACER_TEXT_CONTEXT:
                continue

            if not item.text in expected_items:
                # Item not expected
                if check_contains_no_additional_items:
                    unexpected_items.append(item.text)
            else:
                # Item expected and found, so remove from expected list.
                expected_items.remove(item.text)

                # If have nothing left to find, and we&#39;re not checking for unexpected items, then can break from our loop.
                if not check_contains_no_additional_items and len(expected_items) == 0:
                    break

        # Is there anything left in our expected item list?
        if len(expected_items) &gt; 0:
            raise TreeHelper.ExpectedMenuItemsNotFoundException(tree_cq,
                                                                node_text_or_data,
                                                                expected_items)

        # Was there anything in the menu that was not expected, and we were checking?
        if len(unexpected_items) &gt; 0:
            raise TreeHelper.UnexpectedMenuItemsFoundException(tree_cq,
                                                               node_text_or_data,
                                                               unexpected_items)


    def click_node_expander(self,
                            tree_cq: str,
                            node_text_or_data: Union[str, dict],
                            root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node&#39;s expander element by text or data, then clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        node = self.get_node_expander_element(tree_cq, node_text_or_data, root_node_text_or_data)

        if node:
            if root_node_text_or_data:
                self._logger.info(&#34;Clicking expander on node &#39;%s&#39; (under root &#39;%s&#39;) on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, tree_cq)
            else:
                self._logger.info(&#34;Clicking expander on node &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, tree_cq)

            self._action_chains.move_to_element(node)
            self._action_chains.click(node)
            self._action_chains.perform()
        else:
            raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)

    def click_node_element(self,
                           tree_cq: str,
                           node_text_or_data: Union[str, dict],
                           css_query: str,
                           root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query, then clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            css_query (str): The CSS to query for in the found node row element.
                             Some expected ones:
                                Expander UI element = &#39;.x-tree-expander&#39;
                                Node icon = &#39;.x-tree-icon&#39;
                                Node text = &#39;.x-tree-node-text&#39;
                             If need those you&#39;d use one of the other methods though.
                             This is in case need to click on another part of the node&#39;s row.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        node = self.get_node_element(tree_cq, node_text_or_data, css_query, root_node_text_or_data)

        if node:
            if root_node_text_or_data:
                self._logger.info(&#34;Clicking on node &#39;%s&#39; (under root &#39;%s&#39;), with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, css_query, tree_cq)
            else:
                self._logger.info(&#34;Clicking on node &#39;%s&#39; with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, css_query, tree_cq)

            self._action_chains.move_to_element(node)
            self._action_chains.click(node)
            self._action_chains.perform()
        else:
            raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)

    def context_click_node_element(self,
                                   tree_cq: str,
                                   node_text_or_data: Union[str, dict],
                                   css_query: str,
                                   root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query, then right clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            css_query (str): The CSS to query for in the found node row element.
                             Some expected ones:
                                Expander UI element = &#39;.x-tree-expander&#39;
                                Node icon = &#39;.x-tree-icon&#39;
                                Node text = &#39;.x-tree-node-text&#39;
                             If need those you&#39;d use one of the other methods though.
                             This is in case need to click on another part of the node&#39;s row.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        node = self.get_node_element(tree_cq, node_text_or_data, css_query, root_node_text_or_data)

        if node:
            if root_node_text_or_data:
                self._logger.info(&#34;Right clicking on node &#39;%s&#39; (under root &#39;%s&#39;), with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, css_query, tree_cq)
            else:
                self._logger.info(&#34;Right clicking on node &#39;%s&#39; with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, css_query, tree_cq)

            self._action_chains.move_to_element(node)
            self._action_chains.context_click(node)
            self._action_chains.perform()
        else:
            raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)

    def wait_for_tree_node(self,
                           tree_cq: str,
                           node_text_or_data: Union[str, dict],
                           parent_node_text_or_data: Union[str, dict],
                           timeout: float = 60) -&gt; WebElement:
        &#34;&#34;&#34;Method that waits until a tree node is available, refreshing the parent until it&#39;s
        found or the timeout is hit.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            parent_node_text_or_data (Union[str, dict]): The node text or data to use to find the nodes parent,
                                                         for refreshing purposes.
            timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.

        Returns:
            WebElement: The DOM element for the node icon.
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout).until(TreeHelper.NodeFoundExpectation(tree_cq, node_text_or_data, parent_node_text_or_data))
        return self.get_node_icon_element(tree_cq, node_text_or_data)

    def reload_node(self,
                    tree_cq: str,
                    node_text_or_data: Union[str, dict],
                    root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node by text or data, and triggers a reload on it, and its children.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        self.wait_until_tree_not_loading(tree_cq)

        if isinstance(node_text_or_data, str):
            node_text_or_data = f&#34;&#39;{node_text_or_data}&#39;&#34;

        if isinstance(root_node_text_or_data, str):
            root_node_text_or_data = f&#34;&#39;{root_node_text_or_data}&#39;&#34;

        if root_node_text_or_data:
            script = self._RELOAD_NODE_WITH_ROOT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, root_node_text_or_data=root_node_text_or_data)
        else:
            script = self._RELOAD_NODE_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data)

        if root_node_text_or_data:
            self._logger.info(&#34;Reloading node &#39;%s&#39; (under root &#39;%s&#39;) on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, tree_cq)
        else:
            self._logger.info(&#34;Reloading node &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, tree_cq)

        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    class NodeNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we failed to find the specified node&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     root_node_text_or_data: Union[str, dict, None] = None,
                     css_query: Union[str, None] = None):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                tree_cq (str): The CQ used to find the tree
                node_text_or_data (Union[str, dict]): The node text or data that we were looking for
                root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                    Can be an immediate parent, or higher up in the tree.
                css_query (str, optional): The CSS that was queryed for in the node that we were looking for.
            &#34;&#34;&#34;
            if root_node_text_or_data:
                if css_query:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; (under root &#39;{root_node_text_or_data}&#39;) with CSS query &#39;{css_query}&#39; on tree with CQ &#39;{tree_cq}&#39;.&#34;
                else:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; (under root &#39;{root_node_text_or_data}&#39;) on tree with CQ &#39;{tree_cq}&#39;.&#34;
            else:
                if css_query:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; with CSS query &#39;{css_query}&#39; on tree with CQ &#39;{tree_cq}&#39;.&#34;
                else:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; on tree with CQ &#39;{tree_cq}&#39;.&#34;

            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._root_node_text_or_data = root_node_text_or_data
            self._css_query = css_query

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;

            if self._root_node_text_or_data:
                return self.message.format(node_text_or_data=self._node_text_or_data, root_node_text_or_data=self._root_node_text_or_data, css_query=self._css_query, tree_cq=self._tree_cq)
            else:
                return self.message.format(node_text_or_data=self._node_text_or_data, css_query=self._css_query, tree_cq=self._tree_cq)

    class TreeNotLoadingExpectation:
        &#34;&#34;&#34; An expectation for checking that a tree is not loading.&#34;&#34;&#34;

        def __init__(self, tree_cq: str, recheck_time_if_false: Union[float, None] = None):
            &#34;&#34;&#34;Initialises an instance of this class.

            Args:
                tree_cq (str): The CQ used to find the tree
                recheck_time_if_false (float, optional): If we get a value of false (so there is not a call in progress),
                                                         this is the amount of time to wait to check again. Defaults to None.
            &#34;&#34;&#34;
            self._tree_cq = tree_cq
            self._recheck_time_if_false = recheck_time_if_false

        def __call__(self, driver):
            &#34;&#34;&#34;Method that determines whether the tree is loading.&#34;&#34;&#34;
            tree_helper = TreeHelper(driver)

            is_tree_loading = tree_helper.is_tree_loading(self._tree_cq)

            if not is_tree_loading and self._recheck_time_if_false:
                time.sleep(self._recheck_time_if_false)
                is_tree_loading = tree_helper.is_tree_loading(self._tree_cq)

            return not is_tree_loading

    class NodeFoundExpectation:
        &#34;&#34;&#34; An expectation for checking that a node has been found&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     parent_node_text_or_data: Union[str, dict]):
            &#34;&#34;&#34;Initialises an instance of this class.

            Args:
                tree_cq (str): The component query to use to find the tree.
                node_text_or_data (Union[str, dict]): The node text or data to find.
                parent_node_text_or_data (Union[str, dict]): The node text or data to use to find the nodes parent,
                                                            for refreshing purposes.
            &#34;&#34;&#34;
            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._parent_node_text_or_data = parent_node_text_or_data

        def __call__(self, driver):
            &#34;&#34;&#34;Method that determines whether a node was found.

            If the node is not found the parent tree node is refreshed and the load waited for.
            &#34;&#34;&#34;
            tree_helper = TreeHelper(driver)

            node = tree_helper.get_node_icon_element(self._tree_cq, self._node_text_or_data, self._parent_node_text_or_data)
            if node:
                return True

            # Trigger a reload of the parent
            tree_helper.reload_node(self._tree_cq, self._parent_node_text_or_data)
            return False

    class UnexpectedMenuItemsFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we have found unexpected menu items in a context menu&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     unexpected_menu_items: list[str],
                     message: str = &#34;Unexpected menu items {unexpected_menu_items} found on context menu, on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                tree_cq (str): The component query to use to find the tree.
                node_text_or_data (Union[str, dict]): The node text or data to find.
                unexpected_menu_items (list[str]): A list of menu items that were unexpected.
                message (str, optional): The exception message. Defaults to &#34;Unexpected menu items {unexpected_menu_items} found on context menu, on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._unexpected_menu_items = unexpected_menu_items

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(unexpected_menu_items=self._unexpected_menu_items, tree_cq=self._tree_cq, node_text_or_data=self._node_text_or_data)

    class ExpectedMenuItemsNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we have failed to find some expected menu items in a context menu&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     missing_menu_items: list[str],
                     message: str = &#34;Expected menu items {missing_menu_items} not found on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                tree_cq (str): The component query to use to find the tree.
                node_text_or_data (Union[str, dict]): The node text or data to find.
                missing_menu_items (list[str]): A list of menu items that were expected but not found.
                message (str, optional): The exception message. Defaults to &#34;Expected menu items {missing_menu_items} not found on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._missing_menu_items = missing_menu_items

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(missing_menu_items=self._missing_menu_items, tree_cq=self._tree_cq, node_text_or_data=self._node_text_or_data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyseext.tree_helper.TreeHelper"><code class="flex name class">
<span>class <span class="ident">TreeHelper</span></span>
<span>(</span><span>driver: selenium.webdriver.remote.webdriver.WebDriver)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to help with using trees, through Ext's interfaces.</p>
<p>Initialises an instance of this class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>driver</code></strong> :&ensp;<code>WebDriver</code></dt>
<dd>The webdriver to use</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TreeHelper(HasReferencedJavaScript):
    &#34;&#34;&#34;A class to help with using trees, through Ext&#39;s interfaces.&#34;&#34;&#34;

    # Class variables
    _IS_TREE_LOADING_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.isTreeLoading(&#39;{tree_cq}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.isTreeLoading
    Requires the inserts: {tree_cq}&#34;&#34;&#34;

    _GET_NODE_ELEMENT_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.getNodeElement(&#39;{tree_cq}&#39;, {node_text_or_data}, &#39;{css_query}&#39;)&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.getNodeElement
    Requires the inserts: {tree_cq}, {node_text_or_data}, {css_query}&#34;&#34;&#34;

    _GET_NODE_ELEMENT_WITH_ROOT_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.getNodeElement(&#39;{tree_cq}&#39;, {node_text_or_data}, &#39;{css_query}&#39;, {root_node_text_or_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.getNodeElement including a root node to search from
    Requires the inserts: {tree_cq}, {node_text_or_data}, {css_query}, {root_node_text_or_data}&#34;&#34;&#34;

    _RELOAD_NODE_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.reloadNode(&#39;{tree_cq}&#39;, {node_text_or_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.reloadNode
    Requires the inserts: {tree_cq}, {node_text_or_data}&#34;&#34;&#34;

    _RELOAD_NODE_WITH_ROOT_TEMPLATE: str = &#34;return globalThis.PySeExt.TreeHelper.reloadNode(&#39;{tree_cq}&#39;, {node_text_or_data}, {root_node_text_or_data})&#34;
    &#34;&#34;&#34;The script template to use to call the JavaScript method PySeExt.TreeHelper.reloadNode including a root node to search from
    Requires the inserts: {tree_cq}, {node_text_or_data}, {root_node_text_or_data}&#34;&#34;&#34;

    _ICON_CSS_SELECTOR: str = &#34;.x-tree-icon&#34;
    &#34;&#34;&#34;The CSS selector to use with get_node_element to find the node icon element.
    &#34;&#34;&#34;

    _EXPANDER_CSS_SELECTOR: str = &#34;.x-tree-expander&#34;
    &#34;&#34;&#34;The CSS selector to use with get_node_element to find the node expander element.
    &#34;&#34;&#34;

    _NODE_TEXT_CSS_SELECTOR: str = &#34;.x-tree-node-text&#34;
    &#34;&#34;&#34;The CSS selector to use with get_node_element to find the node text element.
    &#34;&#34;&#34;

    def __init__(self, driver: WebDriver):
        &#34;&#34;&#34;Initialises an instance of this class

        Args:
            driver (WebDriver): The webdriver to use
        &#34;&#34;&#34;
        self._logger = logging.getLogger(__name__)
        &#34;&#34;&#34;The Logger instance for this class instance&#34;&#34;&#34;

        self._driver = driver
        &#34;&#34;&#34;The WebDriver instance for this class instance&#34;&#34;&#34;

        self._action_chains = ActionChains(driver)
        &#34;&#34;&#34;The ActionChains instance for this class instance&#34;&#34;&#34;

        self._core = Core(driver)
        &#34;&#34;&#34;The `Core` instance for this class instance&#34;&#34;&#34;

        self._menu_helper = MenuHelper(driver)
        &#34;&#34;&#34;The `MenuHelper` instance for this class instance&#34;&#34;&#34;

        # Initialise our base class
        super().__init__(driver, self._logger)

    def is_tree_loading(self, tree_cq: str):
        &#34;&#34;&#34;Determine whether the tree (any part of it) is currently loading.

        You should call this before calling any tree interaction methods,
        since we cannot pass things back in callbacks!

        Args:
            tree_cq (str): The component query to use to find the tree.

        Returns:
            bool: True if the tree is loaded, False otherwise.
        &#34;&#34;&#34;
        script = self._IS_TREE_LOADING_TEMPLATE.format(tree_cq=tree_cq)
        self.ensure_javascript_loaded()
        return self._driver.execute_script(script)

    def wait_until_tree_not_loading(self,
                                    tree_cq: str,
                                    timeout: float = 30,
                                    poll_frequecy: float = 0.2,
                                    recheck_time_if_false: float = 0.2):
        &#34;&#34;&#34;Waits until the tree identified by the component query is not loading,
        or the timeout is hit

        Args:
            tree_cq (str): The component query for the tree.
            timeout (float, optional): The number of seconds to wait before erroring. Defaults to 30.
            poll_frequency (float, optional): Number of seconds to poll. Defaults to 0.2.
            recheck_time_if_false (float, optional): If we get a result such that no Ajax calls are in progress, this is the amount of time to wait to check again. Defaults to 0.2.
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout, poll_frequency = poll_frequecy).until(TreeHelper.TreeNotLoadingExpectation(tree_cq, recheck_time_if_false))

    def get_node_icon_element(self,
                              tree_cq: str,
                              node_text_or_data: Union[str, dict],
                              root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s icon.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node icon.
        &#34;&#34;&#34;
        return self.get_node_element(tree_cq, node_text_or_data, self._ICON_CSS_SELECTOR, root_node_text_or_data)

    def get_node_text_element(self,
                              tree_cq: str,
                              node_text_or_data: Union[str, dict],
                              root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s text.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node text.
        &#34;&#34;&#34;
        return self.get_node_element(tree_cq, node_text_or_data, self._NODE_TEXT_CSS_SELECTOR, root_node_text_or_data)

    def get_node_expander_element(self,
                                  tree_cq: str,
                                  node_text_or_data: Union[str, dict],
                                  root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s expander UI element.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node&#39;s expander.
        &#34;&#34;&#34;
        return self.get_node_element(tree_cq, node_text_or_data, self._EXPANDER_CSS_SELECTOR, root_node_text_or_data)

    def get_node_element(self,
                         tree_cq: str,
                         node_text_or_data: Union[str, dict],
                         css_query: str,
                         root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
        &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            css_query (str): The CSS to query for in the found node row element.
                             Some expected ones:
                                Expander UI element = &#39;.x-tree-expander&#39;
                                Node icon = &#39;.x-tree-icon&#39;
                                Node text = &#39;.x-tree-node-text&#39;
                             If need those you&#39;d use one of the other methods though.
                             This is in case need to click on another part of the node&#39;s row.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.

        Returns:
            WebElement: The DOM element for the node&#39;s expander.
        &#34;&#34;&#34;
        self.wait_until_tree_not_loading(tree_cq)

        if isinstance(node_text_or_data, str):
            node_text_or_data = f&#34;&#39;{node_text_or_data}&#39;&#34;

        if isinstance(root_node_text_or_data, str):
            root_node_text_or_data = f&#34;&#39;{root_node_text_or_data}&#39;&#34;

        if root_node_text_or_data:
            script = self._GET_NODE_ELEMENT_WITH_ROOT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, css_query=css_query, root_node_text_or_data=root_node_text_or_data)
        else:
            script = self._GET_NODE_ELEMENT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, css_query=css_query)

        self.ensure_javascript_loaded()
        return self._driver.execute_script(script)

    def open_node_context_menu(self,
                               tree_cq: str,
                               node_text_or_data: Union[str, dict],
                               root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node&#39;s icon element by text or data, then right clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        self.context_click_node_element(tree_cq, node_text_or_data, self._ICON_CSS_SELECTOR, root_node_text_or_data)

    def check_node_context_menu_contains_items(self,
                                               tree_cq: str,
                                               node_text_or_data: Union[str, dict],
                                               expected_items: list[str],
                                               check_contains_no_additional_items: bool = True,
                                               ignore_spacers: bool = False,
                                               root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Opens the context menu for a node, and checks that it contains the specified items.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            expected_items (list[str]): A list of menu items (text) that we&#39;re expecting to find.
                                        Spacers have text containing of a single space (MenuHelper.SPACER_TEXT_CONTEXT), but can be ignored using ignore_spacers if desired.
                                        e.g. [&#39;Add&#39;, &#39;Edit&#39;, &#39;Delete&#39;, MenuHelper.SPACER_TEXT_CONTEXT, &#39;Refresh&#39;]
            check_contains_no_additional_items (bool, optional): Indicates whether we should check that there are no additional items in the menu.
                                                                 Defaults to True.
            ignore_spacers (bool, optional): Indicates whether we should include spacers in our checks. Defaults to False.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        self.open_node_context_menu(tree_cq, node_text_or_data, root_node_text_or_data)

        unexpected_items: list[str] = []

        # Get all menu items
        menu_items = self._menu_helper.get_enabled_menu_items()

        # Each element has a text member we can compare.
        for item in menu_items:
            if ignore_spacers is True and item.text == MenuHelper.SPACER_TEXT_CONTEXT:
                continue

            if not item.text in expected_items:
                # Item not expected
                if check_contains_no_additional_items:
                    unexpected_items.append(item.text)
            else:
                # Item expected and found, so remove from expected list.
                expected_items.remove(item.text)

                # If have nothing left to find, and we&#39;re not checking for unexpected items, then can break from our loop.
                if not check_contains_no_additional_items and len(expected_items) == 0:
                    break

        # Is there anything left in our expected item list?
        if len(expected_items) &gt; 0:
            raise TreeHelper.ExpectedMenuItemsNotFoundException(tree_cq,
                                                                node_text_or_data,
                                                                expected_items)

        # Was there anything in the menu that was not expected, and we were checking?
        if len(unexpected_items) &gt; 0:
            raise TreeHelper.UnexpectedMenuItemsFoundException(tree_cq,
                                                               node_text_or_data,
                                                               unexpected_items)


    def click_node_expander(self,
                            tree_cq: str,
                            node_text_or_data: Union[str, dict],
                            root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node&#39;s expander element by text or data, then clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        node = self.get_node_expander_element(tree_cq, node_text_or_data, root_node_text_or_data)

        if node:
            if root_node_text_or_data:
                self._logger.info(&#34;Clicking expander on node &#39;%s&#39; (under root &#39;%s&#39;) on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, tree_cq)
            else:
                self._logger.info(&#34;Clicking expander on node &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, tree_cq)

            self._action_chains.move_to_element(node)
            self._action_chains.click(node)
            self._action_chains.perform()
        else:
            raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)

    def click_node_element(self,
                           tree_cq: str,
                           node_text_or_data: Union[str, dict],
                           css_query: str,
                           root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query, then clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            css_query (str): The CSS to query for in the found node row element.
                             Some expected ones:
                                Expander UI element = &#39;.x-tree-expander&#39;
                                Node icon = &#39;.x-tree-icon&#39;
                                Node text = &#39;.x-tree-node-text&#39;
                             If need those you&#39;d use one of the other methods though.
                             This is in case need to click on another part of the node&#39;s row.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        node = self.get_node_element(tree_cq, node_text_or_data, css_query, root_node_text_or_data)

        if node:
            if root_node_text_or_data:
                self._logger.info(&#34;Clicking on node &#39;%s&#39; (under root &#39;%s&#39;), with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, css_query, tree_cq)
            else:
                self._logger.info(&#34;Clicking on node &#39;%s&#39; with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, css_query, tree_cq)

            self._action_chains.move_to_element(node)
            self._action_chains.click(node)
            self._action_chains.perform()
        else:
            raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)

    def context_click_node_element(self,
                                   tree_cq: str,
                                   node_text_or_data: Union[str, dict],
                                   css_query: str,
                                   root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query, then right clicks on it.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            css_query (str): The CSS to query for in the found node row element.
                             Some expected ones:
                                Expander UI element = &#39;.x-tree-expander&#39;
                                Node icon = &#39;.x-tree-icon&#39;
                                Node text = &#39;.x-tree-node-text&#39;
                             If need those you&#39;d use one of the other methods though.
                             This is in case need to click on another part of the node&#39;s row.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        node = self.get_node_element(tree_cq, node_text_or_data, css_query, root_node_text_or_data)

        if node:
            if root_node_text_or_data:
                self._logger.info(&#34;Right clicking on node &#39;%s&#39; (under root &#39;%s&#39;), with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, css_query, tree_cq)
            else:
                self._logger.info(&#34;Right clicking on node &#39;%s&#39; with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, css_query, tree_cq)

            self._action_chains.move_to_element(node)
            self._action_chains.context_click(node)
            self._action_chains.perform()
        else:
            raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)

    def wait_for_tree_node(self,
                           tree_cq: str,
                           node_text_or_data: Union[str, dict],
                           parent_node_text_or_data: Union[str, dict],
                           timeout: float = 60) -&gt; WebElement:
        &#34;&#34;&#34;Method that waits until a tree node is available, refreshing the parent until it&#39;s
        found or the timeout is hit.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            parent_node_text_or_data (Union[str, dict]): The node text or data to use to find the nodes parent,
                                                         for refreshing purposes.
            timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.

        Returns:
            WebElement: The DOM element for the node icon.
        &#34;&#34;&#34;
        WebDriverWait(self._driver, timeout).until(TreeHelper.NodeFoundExpectation(tree_cq, node_text_or_data, parent_node_text_or_data))
        return self.get_node_icon_element(tree_cq, node_text_or_data)

    def reload_node(self,
                    tree_cq: str,
                    node_text_or_data: Union[str, dict],
                    root_node_text_or_data: Union[str, dict, None] = None):
        &#34;&#34;&#34;Finds a node by text or data, and triggers a reload on it, and its children.

        Args:
            tree_cq (str): The component query to use to find the tree.
            node_text_or_data (Union[str, dict]): The node text or data to find.
            root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                 Can be an immediate parent, or higher up in the tree.
        &#34;&#34;&#34;
        self.wait_until_tree_not_loading(tree_cq)

        if isinstance(node_text_or_data, str):
            node_text_or_data = f&#34;&#39;{node_text_or_data}&#39;&#34;

        if isinstance(root_node_text_or_data, str):
            root_node_text_or_data = f&#34;&#39;{root_node_text_or_data}&#39;&#34;

        if root_node_text_or_data:
            script = self._RELOAD_NODE_WITH_ROOT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, root_node_text_or_data=root_node_text_or_data)
        else:
            script = self._RELOAD_NODE_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data)

        if root_node_text_or_data:
            self._logger.info(&#34;Reloading node &#39;%s&#39; (under root &#39;%s&#39;) on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, tree_cq)
        else:
            self._logger.info(&#34;Reloading node &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, tree_cq)

        self.ensure_javascript_loaded()
        self._driver.execute_script(script)

    class NodeNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we failed to find the specified node&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     root_node_text_or_data: Union[str, dict, None] = None,
                     css_query: Union[str, None] = None):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                tree_cq (str): The CQ used to find the tree
                node_text_or_data (Union[str, dict]): The node text or data that we were looking for
                root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                                    Can be an immediate parent, or higher up in the tree.
                css_query (str, optional): The CSS that was queryed for in the node that we were looking for.
            &#34;&#34;&#34;
            if root_node_text_or_data:
                if css_query:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; (under root &#39;{root_node_text_or_data}&#39;) with CSS query &#39;{css_query}&#39; on tree with CQ &#39;{tree_cq}&#39;.&#34;
                else:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; (under root &#39;{root_node_text_or_data}&#39;) on tree with CQ &#39;{tree_cq}&#39;.&#34;
            else:
                if css_query:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; with CSS query &#39;{css_query}&#39; on tree with CQ &#39;{tree_cq}&#39;.&#34;
                else:
                    self.message = &#34;Failed to find node with data (or text) &#39;{node_text_or_data}&#39; on tree with CQ &#39;{tree_cq}&#39;.&#34;

            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._root_node_text_or_data = root_node_text_or_data
            self._css_query = css_query

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;

            if self._root_node_text_or_data:
                return self.message.format(node_text_or_data=self._node_text_or_data, root_node_text_or_data=self._root_node_text_or_data, css_query=self._css_query, tree_cq=self._tree_cq)
            else:
                return self.message.format(node_text_or_data=self._node_text_or_data, css_query=self._css_query, tree_cq=self._tree_cq)

    class TreeNotLoadingExpectation:
        &#34;&#34;&#34; An expectation for checking that a tree is not loading.&#34;&#34;&#34;

        def __init__(self, tree_cq: str, recheck_time_if_false: Union[float, None] = None):
            &#34;&#34;&#34;Initialises an instance of this class.

            Args:
                tree_cq (str): The CQ used to find the tree
                recheck_time_if_false (float, optional): If we get a value of false (so there is not a call in progress),
                                                         this is the amount of time to wait to check again. Defaults to None.
            &#34;&#34;&#34;
            self._tree_cq = tree_cq
            self._recheck_time_if_false = recheck_time_if_false

        def __call__(self, driver):
            &#34;&#34;&#34;Method that determines whether the tree is loading.&#34;&#34;&#34;
            tree_helper = TreeHelper(driver)

            is_tree_loading = tree_helper.is_tree_loading(self._tree_cq)

            if not is_tree_loading and self._recheck_time_if_false:
                time.sleep(self._recheck_time_if_false)
                is_tree_loading = tree_helper.is_tree_loading(self._tree_cq)

            return not is_tree_loading

    class NodeFoundExpectation:
        &#34;&#34;&#34; An expectation for checking that a node has been found&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     parent_node_text_or_data: Union[str, dict]):
            &#34;&#34;&#34;Initialises an instance of this class.

            Args:
                tree_cq (str): The component query to use to find the tree.
                node_text_or_data (Union[str, dict]): The node text or data to find.
                parent_node_text_or_data (Union[str, dict]): The node text or data to use to find the nodes parent,
                                                            for refreshing purposes.
            &#34;&#34;&#34;
            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._parent_node_text_or_data = parent_node_text_or_data

        def __call__(self, driver):
            &#34;&#34;&#34;Method that determines whether a node was found.

            If the node is not found the parent tree node is refreshed and the load waited for.
            &#34;&#34;&#34;
            tree_helper = TreeHelper(driver)

            node = tree_helper.get_node_icon_element(self._tree_cq, self._node_text_or_data, self._parent_node_text_or_data)
            if node:
                return True

            # Trigger a reload of the parent
            tree_helper.reload_node(self._tree_cq, self._parent_node_text_or_data)
            return False

    class UnexpectedMenuItemsFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we have found unexpected menu items in a context menu&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     unexpected_menu_items: list[str],
                     message: str = &#34;Unexpected menu items {unexpected_menu_items} found on context menu, on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                tree_cq (str): The component query to use to find the tree.
                node_text_or_data (Union[str, dict]): The node text or data to find.
                unexpected_menu_items (list[str]): A list of menu items that were unexpected.
                message (str, optional): The exception message. Defaults to &#34;Unexpected menu items {unexpected_menu_items} found on context menu, on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._unexpected_menu_items = unexpected_menu_items

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(unexpected_menu_items=self._unexpected_menu_items, tree_cq=self._tree_cq, node_text_or_data=self._node_text_or_data)

    class ExpectedMenuItemsNotFoundException(Exception):
        &#34;&#34;&#34;Exception class thrown when we have failed to find some expected menu items in a context menu&#34;&#34;&#34;

        def __init__(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     missing_menu_items: list[str],
                     message: str = &#34;Expected menu items {missing_menu_items} not found on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;):
            &#34;&#34;&#34;Initialises an instance of this exception

            Args:
                tree_cq (str): The component query to use to find the tree.
                node_text_or_data (Union[str, dict]): The node text or data to find.
                missing_menu_items (list[str]): A list of menu items that were expected but not found.
                message (str, optional): The exception message. Defaults to &#34;Expected menu items {missing_menu_items} not found on tree with CQ &#39;{tree_cq}&#39; and node with text or data &#39;{node_text_or_data}&#39;.&#34;.
            &#34;&#34;&#34;
            self.message = message
            self._tree_cq = tree_cq
            self._node_text_or_data = node_text_or_data
            self._missing_menu_items = missing_menu_items

            super().__init__(self.message)

        def __str__(self):
            &#34;&#34;&#34;Returns a string representation of this exception&#34;&#34;&#34;
            return self.message.format(missing_menu_items=self._missing_menu_items, tree_cq=self._tree_cq, node_text_or_data=self._node_text_or_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript">HasReferencedJavaScript</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyseext.tree_helper.TreeHelper.ExpectedMenuItemsNotFoundException"><code class="name">var <span class="ident">ExpectedMenuItemsNotFoundException</span></code></dt>
<dd>
<div class="desc"><p>Exception class thrown when we have failed to find some expected menu items in a context menu</p></div>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.NodeFoundExpectation"><code class="name">var <span class="ident">NodeFoundExpectation</span></code></dt>
<dd>
<div class="desc"><p>An expectation for checking that a node has been found</p></div>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.NodeNotFoundException"><code class="name">var <span class="ident">NodeNotFoundException</span></code></dt>
<dd>
<div class="desc"><p>Exception class thrown when we failed to find the specified node</p></div>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.TreeNotLoadingExpectation"><code class="name">var <span class="ident">TreeNotLoadingExpectation</span></code></dt>
<dd>
<div class="desc"><p>An expectation for checking that a tree is not loading.</p></div>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.UnexpectedMenuItemsFoundException"><code class="name">var <span class="ident">UnexpectedMenuItemsFoundException</span></code></dt>
<dd>
<div class="desc"><p>Exception class thrown when we have found unexpected menu items in a context menu</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyseext.tree_helper.TreeHelper.check_node_context_menu_contains_items"><code class="name flex">
<span>def <span class="ident">check_node_context_menu_contains_items</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], expected_items: list[str], check_contains_no_additional_items: bool = True, ignore_spacers: bool = False, root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens the context menu for a node, and checks that it contains the specified items.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>expected_items</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of menu items (text) that we're expecting to find.
Spacers have text containing of a single space (MenuHelper.SPACER_TEXT_CONTEXT), but can be ignored using ignore_spacers if desired.
e.g. ['Add', 'Edit', 'Delete', MenuHelper.SPACER_TEXT_CONTEXT, 'Refresh']</dd>
<dt><strong><code>check_contains_no_additional_items</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether we should check that there are no additional items in the menu.
Defaults to True.</dd>
<dt><strong><code>ignore_spacers</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether we should include spacers in our checks. Defaults to False.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_node_context_menu_contains_items(self,
                                           tree_cq: str,
                                           node_text_or_data: Union[str, dict],
                                           expected_items: list[str],
                                           check_contains_no_additional_items: bool = True,
                                           ignore_spacers: bool = False,
                                           root_node_text_or_data: Union[str, dict, None] = None):
    &#34;&#34;&#34;Opens the context menu for a node, and checks that it contains the specified items.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        expected_items (list[str]): A list of menu items (text) that we&#39;re expecting to find.
                                    Spacers have text containing of a single space (MenuHelper.SPACER_TEXT_CONTEXT), but can be ignored using ignore_spacers if desired.
                                    e.g. [&#39;Add&#39;, &#39;Edit&#39;, &#39;Delete&#39;, MenuHelper.SPACER_TEXT_CONTEXT, &#39;Refresh&#39;]
        check_contains_no_additional_items (bool, optional): Indicates whether we should check that there are no additional items in the menu.
                                                             Defaults to True.
        ignore_spacers (bool, optional): Indicates whether we should include spacers in our checks. Defaults to False.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.
    &#34;&#34;&#34;
    self.open_node_context_menu(tree_cq, node_text_or_data, root_node_text_or_data)

    unexpected_items: list[str] = []

    # Get all menu items
    menu_items = self._menu_helper.get_enabled_menu_items()

    # Each element has a text member we can compare.
    for item in menu_items:
        if ignore_spacers is True and item.text == MenuHelper.SPACER_TEXT_CONTEXT:
            continue

        if not item.text in expected_items:
            # Item not expected
            if check_contains_no_additional_items:
                unexpected_items.append(item.text)
        else:
            # Item expected and found, so remove from expected list.
            expected_items.remove(item.text)

            # If have nothing left to find, and we&#39;re not checking for unexpected items, then can break from our loop.
            if not check_contains_no_additional_items and len(expected_items) == 0:
                break

    # Is there anything left in our expected item list?
    if len(expected_items) &gt; 0:
        raise TreeHelper.ExpectedMenuItemsNotFoundException(tree_cq,
                                                            node_text_or_data,
                                                            expected_items)

    # Was there anything in the menu that was not expected, and we were checking?
    if len(unexpected_items) &gt; 0:
        raise TreeHelper.UnexpectedMenuItemsFoundException(tree_cq,
                                                           node_text_or_data,
                                                           unexpected_items)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.click_node_element"><code class="name flex">
<span>def <span class="ident">click_node_element</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], css_query: str, root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node by text or data, then a child element by CSS query, then clicks on it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>css_query</code></strong> :&ensp;<code>str</code></dt>
<dd>The CSS to query for in the found node row element.
Some expected ones:
Expander UI element = '.x-tree-expander'
Node icon = '.x-tree-icon'
Node text = '.x-tree-node-text'
If need those you'd use one of the other methods though.
This is in case need to click on another part of the node's row.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_node_element(self,
                       tree_cq: str,
                       node_text_or_data: Union[str, dict],
                       css_query: str,
                       root_node_text_or_data: Union[str, dict, None] = None):
    &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query, then clicks on it.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        css_query (str): The CSS to query for in the found node row element.
                         Some expected ones:
                            Expander UI element = &#39;.x-tree-expander&#39;
                            Node icon = &#39;.x-tree-icon&#39;
                            Node text = &#39;.x-tree-node-text&#39;
                         If need those you&#39;d use one of the other methods though.
                         This is in case need to click on another part of the node&#39;s row.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.
    &#34;&#34;&#34;
    node = self.get_node_element(tree_cq, node_text_or_data, css_query, root_node_text_or_data)

    if node:
        if root_node_text_or_data:
            self._logger.info(&#34;Clicking on node &#39;%s&#39; (under root &#39;%s&#39;), with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, css_query, tree_cq)
        else:
            self._logger.info(&#34;Clicking on node &#39;%s&#39; with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, css_query, tree_cq)

        self._action_chains.move_to_element(node)
        self._action_chains.click(node)
        self._action_chains.perform()
    else:
        raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.click_node_expander"><code class="name flex">
<span>def <span class="ident">click_node_expander</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node's expander element by text or data, then clicks on it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_node_expander(self,
                        tree_cq: str,
                        node_text_or_data: Union[str, dict],
                        root_node_text_or_data: Union[str, dict, None] = None):
    &#34;&#34;&#34;Finds a node&#39;s expander element by text or data, then clicks on it.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.
    &#34;&#34;&#34;
    node = self.get_node_expander_element(tree_cq, node_text_or_data, root_node_text_or_data)

    if node:
        if root_node_text_or_data:
            self._logger.info(&#34;Clicking expander on node &#39;%s&#39; (under root &#39;%s&#39;) on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, tree_cq)
        else:
            self._logger.info(&#34;Clicking expander on node &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, tree_cq)

        self._action_chains.move_to_element(node)
        self._action_chains.click(node)
        self._action_chains.perform()
    else:
        raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.context_click_node_element"><code class="name flex">
<span>def <span class="ident">context_click_node_element</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], css_query: str, root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node by text or data, then a child element by CSS query, then right clicks on it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>css_query</code></strong> :&ensp;<code>str</code></dt>
<dd>The CSS to query for in the found node row element.
Some expected ones:
Expander UI element = '.x-tree-expander'
Node icon = '.x-tree-icon'
Node text = '.x-tree-node-text'
If need those you'd use one of the other methods though.
This is in case need to click on another part of the node's row.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def context_click_node_element(self,
                               tree_cq: str,
                               node_text_or_data: Union[str, dict],
                               css_query: str,
                               root_node_text_or_data: Union[str, dict, None] = None):
    &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query, then right clicks on it.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        css_query (str): The CSS to query for in the found node row element.
                         Some expected ones:
                            Expander UI element = &#39;.x-tree-expander&#39;
                            Node icon = &#39;.x-tree-icon&#39;
                            Node text = &#39;.x-tree-node-text&#39;
                         If need those you&#39;d use one of the other methods though.
                         This is in case need to click on another part of the node&#39;s row.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.
    &#34;&#34;&#34;
    node = self.get_node_element(tree_cq, node_text_or_data, css_query, root_node_text_or_data)

    if node:
        if root_node_text_or_data:
            self._logger.info(&#34;Right clicking on node &#39;%s&#39; (under root &#39;%s&#39;), with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, css_query, tree_cq)
        else:
            self._logger.info(&#34;Right clicking on node &#39;%s&#39; with CSS query &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, css_query, tree_cq)

        self._action_chains.move_to_element(node)
        self._action_chains.context_click(node)
        self._action_chains.perform()
    else:
        raise TreeHelper.NodeNotFoundException(tree_cq, node_text_or_data, root_node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.get_node_element"><code class="name flex">
<span>def <span class="ident">get_node_element</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], css_query: str, root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node by text or data, then a child element by CSS query.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>css_query</code></strong> :&ensp;<code>str</code></dt>
<dd>The CSS to query for in the found node row element.
Some expected ones:
Expander UI element = '.x-tree-expander'
Node icon = '.x-tree-icon'
Node text = '.x-tree-node-text'
If need those you'd use one of the other methods though.
This is in case need to click on another part of the node's row.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the node's expander.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_element(self,
                     tree_cq: str,
                     node_text_or_data: Union[str, dict],
                     css_query: str,
                     root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
    &#34;&#34;&#34;Finds a node by text or data, then a child element by CSS query.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        css_query (str): The CSS to query for in the found node row element.
                         Some expected ones:
                            Expander UI element = &#39;.x-tree-expander&#39;
                            Node icon = &#39;.x-tree-icon&#39;
                            Node text = &#39;.x-tree-node-text&#39;
                         If need those you&#39;d use one of the other methods though.
                         This is in case need to click on another part of the node&#39;s row.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.

    Returns:
        WebElement: The DOM element for the node&#39;s expander.
    &#34;&#34;&#34;
    self.wait_until_tree_not_loading(tree_cq)

    if isinstance(node_text_or_data, str):
        node_text_or_data = f&#34;&#39;{node_text_or_data}&#39;&#34;

    if isinstance(root_node_text_or_data, str):
        root_node_text_or_data = f&#34;&#39;{root_node_text_or_data}&#39;&#34;

    if root_node_text_or_data:
        script = self._GET_NODE_ELEMENT_WITH_ROOT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, css_query=css_query, root_node_text_or_data=root_node_text_or_data)
    else:
        script = self._GET_NODE_ELEMENT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, css_query=css_query)

    self.ensure_javascript_loaded()
    return self._driver.execute_script(script)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.get_node_expander_element"><code class="name flex">
<span>def <span class="ident">get_node_expander_element</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node by text or data, then the child HTML element that holds it's expander UI element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the node's expander.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_expander_element(self,
                              tree_cq: str,
                              node_text_or_data: Union[str, dict],
                              root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
    &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s expander UI element.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.

    Returns:
        WebElement: The DOM element for the node&#39;s expander.
    &#34;&#34;&#34;
    return self.get_node_element(tree_cq, node_text_or_data, self._EXPANDER_CSS_SELECTOR, root_node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.get_node_icon_element"><code class="name flex">
<span>def <span class="ident">get_node_icon_element</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node by text or data, then the child HTML element that holds it's icon.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the node icon.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_icon_element(self,
                          tree_cq: str,
                          node_text_or_data: Union[str, dict],
                          root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
    &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s icon.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.

    Returns:
        WebElement: The DOM element for the node icon.
    &#34;&#34;&#34;
    return self.get_node_element(tree_cq, node_text_or_data, self._ICON_CSS_SELECTOR, root_node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.get_node_text_element"><code class="name flex">
<span>def <span class="ident">get_node_text_element</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node by text or data, then the child HTML element that holds it's text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the node text.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_text_element(self,
                          tree_cq: str,
                          node_text_or_data: Union[str, dict],
                          root_node_text_or_data: Union[str, dict, None] = None) -&gt; WebElement:
    &#34;&#34;&#34;Finds a node by text or data, then the child HTML element that holds it&#39;s text.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.

    Returns:
        WebElement: The DOM element for the node text.
    &#34;&#34;&#34;
    return self.get_node_element(tree_cq, node_text_or_data, self._NODE_TEXT_CSS_SELECTOR, root_node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.is_tree_loading"><code class="name flex">
<span>def <span class="ident">is_tree_loading</span></span>(<span>self, tree_cq: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine whether the tree (any part of it) is currently loading.</p>
<p>You should call this before calling any tree interaction methods,
since we cannot pass things back in callbacks!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the tree is loaded, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_tree_loading(self, tree_cq: str):
    &#34;&#34;&#34;Determine whether the tree (any part of it) is currently loading.

    You should call this before calling any tree interaction methods,
    since we cannot pass things back in callbacks!

    Args:
        tree_cq (str): The component query to use to find the tree.

    Returns:
        bool: True if the tree is loaded, False otherwise.
    &#34;&#34;&#34;
    script = self._IS_TREE_LOADING_TEMPLATE.format(tree_cq=tree_cq)
    self.ensure_javascript_loaded()
    return self._driver.execute_script(script)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.open_node_context_menu"><code class="name flex">
<span>def <span class="ident">open_node_context_menu</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node's icon element by text or data, then right clicks on it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_node_context_menu(self,
                           tree_cq: str,
                           node_text_or_data: Union[str, dict],
                           root_node_text_or_data: Union[str, dict, None] = None):
    &#34;&#34;&#34;Finds a node&#39;s icon element by text or data, then right clicks on it.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.
    &#34;&#34;&#34;
    self.context_click_node_element(tree_cq, node_text_or_data, self._ICON_CSS_SELECTOR, root_node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.reload_node"><code class="name flex">
<span>def <span class="ident">reload_node</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], root_node_text_or_data: Union[str, dict, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a node by text or data, and triggers a reload on it, and its children.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>root_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code>, optional</dt>
<dd>The text or data indicating the root node under which to search for the node.
Can be an immediate parent, or higher up in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload_node(self,
                tree_cq: str,
                node_text_or_data: Union[str, dict],
                root_node_text_or_data: Union[str, dict, None] = None):
    &#34;&#34;&#34;Finds a node by text or data, and triggers a reload on it, and its children.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        root_node_text_or_data (Union[str, dict], optional): The text or data indicating the root node under which to search for the node.
                                                             Can be an immediate parent, or higher up in the tree.
    &#34;&#34;&#34;
    self.wait_until_tree_not_loading(tree_cq)

    if isinstance(node_text_or_data, str):
        node_text_or_data = f&#34;&#39;{node_text_or_data}&#39;&#34;

    if isinstance(root_node_text_or_data, str):
        root_node_text_or_data = f&#34;&#39;{root_node_text_or_data}&#39;&#34;

    if root_node_text_or_data:
        script = self._RELOAD_NODE_WITH_ROOT_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data, root_node_text_or_data=root_node_text_or_data)
    else:
        script = self._RELOAD_NODE_TEMPLATE.format(tree_cq=tree_cq, node_text_or_data=node_text_or_data)

    if root_node_text_or_data:
        self._logger.info(&#34;Reloading node &#39;%s&#39; (under root &#39;%s&#39;) on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, root_node_text_or_data, tree_cq)
    else:
        self._logger.info(&#34;Reloading node &#39;%s&#39; on tree with CQ &#39;%s&#39;&#34;, node_text_or_data, tree_cq)

    self.ensure_javascript_loaded()
    self._driver.execute_script(script)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.wait_for_tree_node"><code class="name flex">
<span>def <span class="ident">wait_for_tree_node</span></span>(<span>self, tree_cq: str, node_text_or_data: Union[str, dict], parent_node_text_or_data: Union[str, dict], timeout: float = 60) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Method that waits until a tree node is available, refreshing the parent until it's
found or the timeout is hit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query to use to find the tree.</dd>
<dt><strong><code>node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to find.</dd>
<dt><strong><code>parent_node_text_or_data</code></strong> :&ensp;<code>Union[str, dict]</code></dt>
<dd>The node text or data to use to find the nodes parent,
for refreshing purposes.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of seconds to wait for the row before erroring. Defaults to 60.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>WebElement</code></dt>
<dd>The DOM element for the node icon.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_tree_node(self,
                       tree_cq: str,
                       node_text_or_data: Union[str, dict],
                       parent_node_text_or_data: Union[str, dict],
                       timeout: float = 60) -&gt; WebElement:
    &#34;&#34;&#34;Method that waits until a tree node is available, refreshing the parent until it&#39;s
    found or the timeout is hit.

    Args:
        tree_cq (str): The component query to use to find the tree.
        node_text_or_data (Union[str, dict]): The node text or data to find.
        parent_node_text_or_data (Union[str, dict]): The node text or data to use to find the nodes parent,
                                                     for refreshing purposes.
        timeout (int, optional): The number of seconds to wait for the row before erroring. Defaults to 60.

    Returns:
        WebElement: The DOM element for the node icon.
    &#34;&#34;&#34;
    WebDriverWait(self._driver, timeout).until(TreeHelper.NodeFoundExpectation(tree_cq, node_text_or_data, parent_node_text_or_data))
    return self.get_node_icon_element(tree_cq, node_text_or_data)</code></pre>
</details>
</dd>
<dt id="pyseext.tree_helper.TreeHelper.wait_until_tree_not_loading"><code class="name flex">
<span>def <span class="ident">wait_until_tree_not_loading</span></span>(<span>self, tree_cq: str, timeout: float = 30, poll_frequecy: float = 0.2, recheck_time_if_false: float = 0.2)</span>
</code></dt>
<dd>
<div class="desc"><p>Waits until the tree identified by the component query is not loading,
or the timeout is hit</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree_cq</code></strong> :&ensp;<code>str</code></dt>
<dd>The component query for the tree.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The number of seconds to wait before erroring. Defaults to 30.</dd>
<dt><strong><code>poll_frequency</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Number of seconds to poll. Defaults to 0.2.</dd>
<dt><strong><code>recheck_time_if_false</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>If we get a result such that no Ajax calls are in progress, this is the amount of time to wait to check again. Defaults to 0.2.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until_tree_not_loading(self,
                                tree_cq: str,
                                timeout: float = 30,
                                poll_frequecy: float = 0.2,
                                recheck_time_if_false: float = 0.2):
    &#34;&#34;&#34;Waits until the tree identified by the component query is not loading,
    or the timeout is hit

    Args:
        tree_cq (str): The component query for the tree.
        timeout (float, optional): The number of seconds to wait before erroring. Defaults to 30.
        poll_frequency (float, optional): Number of seconds to poll. Defaults to 0.2.
        recheck_time_if_false (float, optional): If we get a result such that no Ajax calls are in progress, this is the amount of time to wait to check again. Defaults to 0.2.
    &#34;&#34;&#34;
    WebDriverWait(self._driver, timeout, poll_frequency = poll_frequecy).until(TreeHelper.TreeNotLoadingExpectation(tree_cq, recheck_time_if_false))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript">HasReferencedJavaScript</a></b></code>:
<ul class="hlist">
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.JavaScriptLoadedExpectation" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.JavaScriptLoadedExpectation">JavaScriptLoadedExpectation</a></code></li>
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.ensure_javascript_loaded" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.ensure_javascript_loaded">ensure_javascript_loaded</a></code></li>
<li><code><a title="pyseext.has_referenced_javascript.HasReferencedJavaScript.get_async_script_content" href="has_referenced_javascript.html#pyseext.has_referenced_javascript.HasReferencedJavaScript.get_async_script_content">get_async_script_content</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyseext" href="index.html">pyseext</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyseext.tree_helper.TreeHelper" href="#pyseext.tree_helper.TreeHelper">TreeHelper</a></code></h4>
<ul class="">
<li><code><a title="pyseext.tree_helper.TreeHelper.ExpectedMenuItemsNotFoundException" href="#pyseext.tree_helper.TreeHelper.ExpectedMenuItemsNotFoundException">ExpectedMenuItemsNotFoundException</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.NodeFoundExpectation" href="#pyseext.tree_helper.TreeHelper.NodeFoundExpectation">NodeFoundExpectation</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.NodeNotFoundException" href="#pyseext.tree_helper.TreeHelper.NodeNotFoundException">NodeNotFoundException</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.TreeNotLoadingExpectation" href="#pyseext.tree_helper.TreeHelper.TreeNotLoadingExpectation">TreeNotLoadingExpectation</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.UnexpectedMenuItemsFoundException" href="#pyseext.tree_helper.TreeHelper.UnexpectedMenuItemsFoundException">UnexpectedMenuItemsFoundException</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.check_node_context_menu_contains_items" href="#pyseext.tree_helper.TreeHelper.check_node_context_menu_contains_items">check_node_context_menu_contains_items</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.click_node_element" href="#pyseext.tree_helper.TreeHelper.click_node_element">click_node_element</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.click_node_expander" href="#pyseext.tree_helper.TreeHelper.click_node_expander">click_node_expander</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.context_click_node_element" href="#pyseext.tree_helper.TreeHelper.context_click_node_element">context_click_node_element</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.get_node_element" href="#pyseext.tree_helper.TreeHelper.get_node_element">get_node_element</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.get_node_expander_element" href="#pyseext.tree_helper.TreeHelper.get_node_expander_element">get_node_expander_element</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.get_node_icon_element" href="#pyseext.tree_helper.TreeHelper.get_node_icon_element">get_node_icon_element</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.get_node_text_element" href="#pyseext.tree_helper.TreeHelper.get_node_text_element">get_node_text_element</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.is_tree_loading" href="#pyseext.tree_helper.TreeHelper.is_tree_loading">is_tree_loading</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.open_node_context_menu" href="#pyseext.tree_helper.TreeHelper.open_node_context_menu">open_node_context_menu</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.reload_node" href="#pyseext.tree_helper.TreeHelper.reload_node">reload_node</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.wait_for_tree_node" href="#pyseext.tree_helper.TreeHelper.wait_for_tree_node">wait_for_tree_node</a></code></li>
<li><code><a title="pyseext.tree_helper.TreeHelper.wait_until_tree_not_loading" href="#pyseext.tree_helper.TreeHelper.wait_until_tree_not_loading">wait_until_tree_not_loading</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>